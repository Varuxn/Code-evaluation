id,desc,desc_zh,data,time_limit,memory_limit,std,generator,test,cate,difficulty,mem_std,,,,,,,,,,,,,,,
luogu1,"Give an integer N and K transformation rules.
Rules:
- Change one digit to another.
- The right part of the rule cannot be zero.
Find out how many different integers can be produced by any number of transformations (0 or more).
Only the number of outputs is required.

solution main function
```cpp
class Solution
{
public:
string solve(string N, int K, vector<pair<int,int> > &rules)
}
```
Example 1:
Input: N = 234, K = 2, rules = [ [2, 5], [3, 6] ]
Output: 4

Restrictions:
0<N<10^@data,0<K<@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给出一个整数 N 和 K 个变换规则。
规则：
- 一位数可变换成另一个一位数。
- 规则的右部不能为零。
求出经过任意次的变换（0 次或多次），能产生出多少个不同整数。
仅要求输出个数。

solution内主函数
```cpp
class Solution
{
public:
string solve(string N, int K, vector<pair<int,int> > &rules)
}
```

样例1：
Input：N = 234, K = 2, rules = [ [2, 5], [3, 6] ]
Output: 4

限制：
0<N<10^@data,0<K<@data
时间限制：@time_limit ms
内存限制：@memory_limit KB",5 10 15,1000,6400 640 64,"class Solution
{
public:
	bool tag[10][10]={};
	int d[10]={};
	int p[1000]={};
    string solve(string a, int n, vector<pair<int,int> > &rules)
    {
        string ans;
        int x,y;
        for(int i=0;i<n;i++)
            tag[rules[i].first][rules[i].second]=1;
	    for(int k=1;k<=9;k++)
	        for(int i=0;i<=9;i++)
	            for(int j=1;j<=9;j++)
	                if(tag[i][k]&&tag[k][j]) tag[i][j]=1;
        for(int i=0;i<10;i++)
        {
            tag[i][i]=1;
            for(int j=0;j<10;j++)
                if(tag[i][j])
                d[i]++;
        }
        int z=0;
        p[0]=1;
        for(int i=0;a[i];i++)
        {
            z=0;
            int x=d[a[i]-'0'];
            for(int i=0;i<500;i++)
            {
                p[i]=(p[i]*x+z);
                z=p[i]/10;
                p[i]%=10;
            }
        }
        int i=500;
        while(p[i]==0) i--;
        for(;i>=0;i--) ans.push_back(p[i]+'0');
        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

void cand(int m, int n) { // Generate m cands from 1 to n
    for (int i = 0; i < m; i++) {
        int l = rng(1, n);
        int r = rng(1, n);

        if (l > r) {
            std::swap(l, r);
        }

        std::cout << l << "" "" << r << ""\n"";
    }
}

void tree(int n) { // Generate a tree with n vertices
    int m = 1E9;
    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        int v = rng(1, m);
        std::cout << p + 1 << "" "" << i + 1 << "" "" << v << ""\n"";
    }
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = f[std::make_pair(i, p)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x + 1 << "" "" << y + 1 << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    // int N = rng(1, data);
    string N;
    int len=rng(1, data),K = rng(1, data);
    putchar(rng('1','9'));
    for(int i=2;i<=len;i++) putchar(rng('0','9'));
    std::cout <<"" "" << K << ""\n"";
    for(int i=1;i<=K;i++)
    {
        int x=rng(0,9),y=rng(0,9);
        printf(""%d %d\n"",x,y);
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    string N;
    int K; cin >> N >> K;
    vector<pair<int,int> > rules;
    for (int i = 0; i < K; i++)
    {
        int x,y; cin >>x>>y;
        rules.push_back({x,y});
    }

    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(N,K,rules);
    get_usage(argv[0], argv[1]);

    // output
    cout << result ;

    return 0;
}",Floyd,hard,,,,,,,,,,,,,,,,
luogu2,"In class, there are always some classmates who talk to people before and after, which is a headache for the head teacher in primary school. However, the head teacher Xiaoxue found some interesting phenomenon, when the students' seats are determined, only a limited number of $D$to the students will talk to each other in class.
In the classroom, the students sit in the $M$row $N$column, and the students sitting in the $j$column of the $i$row are in the position of $(i,j)$. In order to facilitate students to enter and exit, the classroom is set up a horizontal channel of $K$and a vertical channel of $L$.
So, the clever snow came up with a way that might reduce the problem of students talking to each other in class: she planned to rearrange the tables and chairs and change the position of the passage between the students' desks and chairs, because if a passage separated $2 students who could talk to each other, then they would not talk to each other.
Please help to write a program for Xiaoxue to give the best channel division scheme. Under this scheme, the number of students who talk to each other in class is the lowest.

solution main function
```cpp
class Solution
{
    public:
    pair<vector<int>,vector<int> > solve(int M,int N,int K,int L,int D, vector<vector<int> > &seats)
}
```

Pass in parameters:
5 integers, $M,N,K,L,D$, meaning as shown on the surface.
seats A row of four integers $X_i,Y_i,P_i,Q_i$indicates that two students sitting at $(X_i,Y_i)$and $(P_i,Q_i)$will talk to each other (make sure they are next to each other or next to each other).
The input data ensures the uniqueness of the optimal solution.

Return parameters:
Two vector arrays
The first array contains $K $$a_1 integers, a_2, \ ldots, a_K $, said the first $line a_1 $and $a_1 + 1 $line, between the first $a_2 $, between line and $a_2 + 1 $... A channel is opened between the $a_K$and $a_K+1$lines, where $a_i< a_{i+1}$.
The second array containing $L $$b_1 integers, b_2, \ ldots, b_L $, said the first $b_1 $and $b_1 + 1 $row between, the first $b_2 $and $b_2 + 1 $row between,... A channel is opened between columns $b_L$and $b_L+1$, where $b_i< b_{i+1}$.

Example 1:
Input : M = 4, N = 5, K = 1, L = 2, D = 3 ,seats = [ [4, 2, 4, 3],  [2, 3, 3, 3],  [2, 5, 2, 4] ]
output : [ [ 2],[2, 4] ]  
```  
---

Restrictions:
2≤N,M≤@data
2≤D≤3*@data
0≤K≤M,0≤L≤N
Time limit: @time_limit ms  
Memory limit: @memory_limit KB","上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。
同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。
于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。
请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。

solution内主函数
```cpp
class Solution
{
    public:
    pair<vector<int>,vector<int> > solve(int M,int N,int K,int L,int D, vector<vector<int> > &seats)
}
```

传入参数:
5个整数，分别是 $M,N,K,L,D$，含义如题面所示。
seats二维变量，每一行有 4 个整数 $X_i,Y_i,P_i,Q_i$ 表示坐在位置 $(X_i,Y_i)$ 与 $(P_i,Q_i)$ 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。
输入数据保证最优方案的唯一性。

返回参数:
两个vector数组
第一个数组包含 $K$ 个整数 $a_1,a_2,\ldots,a_K$，表示第 $a_1$ 行和 $a_1+1$ 行之间、第 $a_2$ 行和 $a_2+1$ 行之间、…、第 $a_K$ 行和第 $a_K+1$ 行之间要开辟通道，其中 $a_i< a_{i+1}$。
第二个数组包含 $L$ 个整数 $b_1,b_2,\ldots,b_L$，表示第 $b_1$ 列和 $b_1+1$ 列之间、第 $b_2$ 列和 $b_2+1$ 列之间、…、第 $b_L$ 列和第 $b_L+1$ 列之间要开辟通道，其中 $b_i< b_{i+1}$。

样例1：
Input : M = 4, N = 5, K = 1, L = 2, D = 3 ,seats = [ [4, 2, 4, 3],  [2, 3, 3, 3],  [2, 5, 2, 4] ]
output : [ [ 2],[2, 4] ]  
```  
---

限制:
2≤N,M≤@data
2≤D≤3*@data
0≤K≤M,0≤L≤N
时间限制: @time_limit ms  
内存限制: @memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution {
    struct A {
        int n, p; 
    };

    bool cmp(A x, A y) {
        return x.n > y.n;
    }

    bool cmp1(A x, A y) {
        return x.p < y.p;
    }
public:
    pair<vector<int>, vector<int>> solve(int M, int N, int K, int L, int D, vector<vector<int>>& seats) {
        vector<A> row(M + 1), col(N + 1);
        vector<int> row_divisions, col_divisions;

        for (const auto& edge : seats) {
            int x1 = edge[0], y1 = edge[1], x2 = edge[2], y2 = edge[3];
            if (x1 == x2) {
                int idx = min(y1, y2);
                col[idx].p = idx;
                col[idx].n++;
            } else {
                int idx = min(x1, x2);
                row[idx].p = idx;
                row[idx].n++;
            }
        }

        sort(row.begin() + 1, row.begin() + M + 1, cmp);
        sort(col.begin() + 1, col.begin() + N + 1, cmp);

        sort(row.begin() + 1, row.begin() + K + 1, cmp1); 
        sort(col.begin() + 1, col.begin() + L + 1, cmp1);

        for (int i = 1; i <= K; i++) row_divisions.push_back(row[i].p);
        for (int i = 1; i <= L; i++) col_divisions.push_back(col[i].p);

        return {row_divisions, col_divisions};
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int m,n,k,l,d;
    cin>>m>>n>>k>>l>>d;
    vector<vector<int> > seats;
    for(int i=1;i<=d;i++)
    {
        vector<int> temp;
        for(int j=1,x;j<=4;j++)
        {
            cin>>x;
            temp.push_back(x);
        }
        seats.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    pair<vector<int>,vector<int> > result = solution.solve(m,n,k,l,d,seats);
    get_usage(argv[0], argv[1]);

    // output
    for(int i=0;i<result.first.size();i++)
    {
        printf(""%d"",result.first[i]);
        if(i==result.first.size()-1) cout<<endl;
        else cout<<' ';
    }
    for(int i=0;i<result.second.size();i++)
    {
        printf(""%d"",result.second[i]);
        if(i==result.second.size()-1);
        else cout<<' ';
    }
    return 0;
}",avarice,hard,,,,,,,,,,,,,,,,
luogu4,"There is A crossing pawn at $A$on the board that needs to go to the target $B$point. Pawn walking rules: can go down, or right. At the same time, there is an opposing horse at the $C$point on the board, and the point where the horse is located and all the points reachable by the jump step are called the control point of the opposing horse. Therefore, it is called ""horse blocking the river and pawn"".
The board is represented by coordinates, $A$point $(0, 0)$, $B$point $(n, m)$, and the same horse position coordinates need to be given.
Now you are asked to calculate the number of paths that the pawn can take from point $A$to point $B$, assuming that the position of the horse is fixed, not that the pawn moves one step at a time.

solution main function
```cpp
class Solution
{
    public:
    long long solve(int n, int m, int x, int y)
}
```
Pass in parameters:
Four integers, $n,m,x,y$, represent the coordinates of point B and horse, respectively.

Return parameters:
An integer indicating the number of all paths.

Example 1:
Input: n=6,m=6,x=3,y=3
Output: 6

Restrictions:
0<n,m,x,y≤@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。
棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。
现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

solution内主函数
```cpp
class Solution
{
    public:
    long long solve(int n, int m, int x, int y)
}
```

传入参数:
4个整数，分别是 $n,m,x,y$，分别表示 B 点坐标和马的坐标。

返回参数:
一个整数，表示所有的路径条数。

样例1：
Input：n=6,m=6,x=3,y=3
Output: 6

限制：
0<n,m,x,y≤@data
时间限制：@time_limit ms
内存限制：@memory_limit KB",8 10 20,1000,6400 640 64,"class Solution {
public:
    long long solve(int n, int m, int x, int y) {
        int bx = n + 2, by = m + 2, mx = x + 2, my = y + 2;
        vector<long long> f(by + 1, 0);
        f[2] = 1;

        auto check = [&](int i, int j) {
            if (i == mx && j == my) return true;
            return (abs(mx - i) + abs(my - j) == 3) && (max(abs(mx - i), abs(my - j)) == 2);
        };

        for (int i = 2; i <= bx; i++) {
            for (int j = 2; j <= by; j++) {
                if (check(i, j)) {
                    f[j] = 0;
                } else {
                    f[j] += f[j - 1];
                }
            }
        }

        return f[by];
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m,x,y;
    cin>>n>>m>>x>>y;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n, m, x, y);
    get_usage(argv[0], argv[1]);

    // output
    cout << result ;

    return 0;
}",dp,middle,,,,,,,,,,,,,,,,
luogu5,"Xiao Ming's flower shop has just opened. In order to attract customers, he wants to put a row of flowers in front of the shop, with a total of $m$POTS. By investigating customers' preferences, Xiao Ming made a list of customers' favorite $n$flowers. In order to display more flowers at the door, it is stipulated that the $i$flower can not exceed the $a_i$pot, and the same flower is placed together when the flowers are arranged, and the different kinds of flowers need to be arranged in order from the smallest to the largest according to the label.
Try programming to figure out how many different flower arrangements there are.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &a)
}
```
Example 1:
Input: n=2,m=4,a=[3, 2]
Output: 2

Restrictions:
0<n,m≤@data
0≤a[i]≤100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。
试编程计算，一共有多少种不同的摆花方案。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &a)
}
```

样例1：
Input：n=2,m=4,a=[3, 2]
Output: 2

限制：
0<n,m≤@data
0≤a[i]≤100
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 50 100,1000,6400 640 64,"class Solution
{
public:
    int solve(int n, int m, vector<int> &a)
    {
        const int mod = 1000007;
        a.insert(a.begin(), 0);
        vector<int> f(m + 1, 0), sum(m + 1, 0);
        f[0] = 1;

        for (int i = 0; i <= m; i++) 
            sum[i] = 1;

        for (int i = 1; i <= n; i++)
        {
            for (int j = m; j >= 1; j--)
            {
                int t = j - min(a[i], j) - 1;
                if (t < 0)
                    f[j] = (f[j] + sum[j - 1]) % mod;
                else
                    f[j] = (f[j] + sum[j - 1] - sum[t] + mod) % mod;
            }

            for (int j = 1; j <= m; j++)
                sum[j] = (sum[j - 1] + f[j]) % mod;
        }

        return f[m];
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    vector<int> a;
    cin>>n>>m;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }

    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,m,a);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard,,,,,,,,,,,,,,,,
luogu6,"Bracteoles are ready to drive down the road.
There are $n$stops on the highway, numbered from $1$to $n$. The distance between site $i$and site $i + 1$is $v_i$km.
Every station on the highway can be refueled, the price of a liter of gas at the station numbered $i$is $a_i$, and each station only sells integer liters of gas.
The Bract wants to drive from the site $1 to the site $n$. At first the Bract is at the site $1 and the tank of the car is empty. It is known that the tank of the car is large enough to hold as much oil as it wants, and it can move forward $d$km per liter of oil. Ask the bract from the site $1$to the site $n$, at least how much money to spend on fuel?

solution main function
```cpp
class Solution
{
    public:
        long long solve(int n, int d, vector<int> &v, vector<int> &a)
}
```
Pass in parameters:
2 integers, $n,d$.
2 arrays, v containing $n-1 $positive integers $v_1, v_2\dots v_{n-1}$, respectively, representing the distance between sites.
a contains $n$positive integers $a_1, a_2 \dots a_n$, which represent the price of refueling at different stations.

Return parameters:
An integer indicating how much the bract must spend to refuel from the site $1$to the site $n$.

Example 1:
Input: n = 5, d = 4, n = [10, 10, 10, 10], a = [9, 8, 9, 6, 5]
Output: 79

Restrictions:
1≤n≤@data, 1≤d≤10^ 5,1 ≤a[i],v[i] ≤10^5
Time limit: @time_limit ms
Memory limit: @memory_limit KB","小苞准备开着车沿着公路自驾。
公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。
公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。
小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？

solution内主函数
```cpp
class Solution
{
    public:
        long long solve(int n, int d, vector<int> &v, vector<int> &a)
}
```

传入参数:
2个整数，分别是 $n,d$。
2个数组，v包含 $n - 1$ 个正整数 $v_1, v_2\dots v_{n-1}$，分别表示站点间的距离。
        a包含 $n$ 个正整数 $a_1, a_2 \dots a_n$，分别表示在不同站点加油的价格。

返回参数:
一个整数，表示从站点 $1$ 开到站点 $n$，小苞至少要花多少钱加油。。

样例1：
Input：n=5,d=4,v=[10, 10, 10, 10],a=[9, 8, 9, 6, 5]
Output: 79

限制：
1≤n≤@data，1≤d≤10^5，1≤a[i],v[i]​≤10^5
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 1000 100000,1000,6400 640 64,"class Solution
{
public:
    long long solve(int n, int d, vector<int> &v, vector<int> &a)
    {
        long long ans = 0, s = 0;
        int mi = INT_MAX;
        v.insert(v.begin(), 0);
        a.insert(a.begin(), 0);
        for (int i = 1; i < n; i++)
        {
            s += v[i];
            mi = min(mi, a[i]);
            if (s > 0)
            {
                ans += (s + d - 1) / d * mi;
                s -= (s + d - 1) / d * d;
            }
        }

        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

void cand(int m, int n) { // Generate m cands from 1 to n
    for (int i = 0; i < m; i++) {
        int l = rng(1, n);
        int r = rng(1, n);

        if (l > r) {
            std::swap(l, r);
        }

        std::cout << l << "" "" << r << ""\n"";
    }
}

void tree(int n) { // Generate a tree with n vertices
    int m = 1E9;
    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        int v = rng(1, m);
        std::cout << p + 1 << "" "" << i + 1 << "" "" << v << ""\n"";
    }
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = f[std::make_pair(i, p)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x + 1 << "" "" << y + 1 << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n = rng(1, data);
    int d = rng(1, 100000);
    std::cout << n << "" "" << d << ""\n"";
    array(n-1, 100000);
    array(n, 10000);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,d; cin>>n>>d;
    vector<int> dist,val;
    for(int i=1,x;i<n;i++)
    {
        cin>>x;
        dist.push_back(x);
    }
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        val.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,d,dist,val);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,middle,,,,,,,,,,,,,,,,
luogu7,"Xuan Xuan and Kai Kai are playing a game called ""Dragon Tiger Fight"", the game board is a line segment, there are $n$barracks on the line segment (numbered $1 \sim n$from left to right), and the adjacent numbered barracks are separated by $1$cm, that is, the board is a line segment with a length of $n-1$cm. There are $c_i$engineers in the $i$barracks.
Xuan Xuan is on the left, representing ""dragon""; Kai Kai is on the right, representing ""Tiger"". They use barracks $m$as a demarcation line, the sappers on the left belong to the Dragon force, the sappers on the right belong to the tiger force, and the sappers in barracks $m$are very tangled, they don't belong to either side.
The momentum of a barracks is: the number of engineers in the barracks $\times $the distance between the barracks and the $m$barracks; The power of a party participating in the game is defined as the sum of the momentum of all the barracks belonging to that party.
During the game, at some point, a total of $s_1$engineers suddenly appeared in the $p_1$barracks. As a friend of Xuan Xuan and Kai Kai, you know that if the gap between the two sides is too great, Xuan Xuan and Kai Kai are not willing to continue to play. In order for the game to continue, you need to select a barracks $p_2$and send all your $s_2$engineers to the barracks $p_2$, making the momentum gap between the two sides as small as possible.
Note: The sengineer you hold in the barracks has the same power as the other Sengineers in that barracks (if you fall in the $m$barracks, you don't belong to any power).

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, int m, int p1, int s1, int s2, vector<int> &c)
}
```

Pass in parameters:
5 integers: $n,m,p_1,s_1,s_2$.
1 array, c contains $n$positive integers, the first positive integer represents the number of engineers in the barracks numbered $i$at the beginning of $c_i$.

Return parameters:
An integer $p_2$indicates the barracks number you selected. If multiple numbers are optimal, the smallest number is used.

Example 1:
Input: n=6,m=4,p1=6,s1=5,s2=2,c=[2, 3, 2, 3, 2, 3]
Output: 2

Example 2:
Input: n = 6, m = 5, p = 4, s1 = 1, s2 = 1, c = [1, 1, 1, 1, 1, 16]
Output: 1

Restrictions:
1<m<n, 1≤p1≤n, 1≤n≤@data, 1≤c[i],s1,s2 ≤10^9
Time limit: @time_limit ms
Memory limit: @memory_limit KB","轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$ 位工兵。
轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    
一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。
游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 
 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, int m, int p1, int s1, int s2, vector<int> &c)
}
```

传入参数:
5个整数，分别是 $n,m,p_1,s_1,s_2$。
1个数组，c包含 $n$ 个正整数，第 $i$ 个正整数代表编号为 $i$ 的兵营中起始时的工兵数量 $c_i$。。

返回参数:
一个整数 $p_2$，表示你选择的兵营编号。如果存在多个编号同时满足最优，取最小的编号。

样例1：
Input：n=6,m=4,p1=6,s1=5,s2=2,c=[2, 3, 2, 3, 2, 3]
Output: 2

样例2：
Input：n=6,m=5,p1=4,s1=1,s2=1,c=[1, 1, 1, 1, 1, 16]
Output: 1

限制：
1<m<n，1≤p1≤n，1≤n≤@data，1≤c[i],s1,s2​≤10^9
时间限制：@time_limit ms
内存限制：@memory_limit KB",5 100 100000,1000,6400 640 64,"class Solution
{
public:
    int solve(int n, int m, int p1, int s1, int s2, vector<int> &c)
    {
        c.insert(c.begin(), 0);
        long long gap = 0;
        double where;
        long long ans;
        c[p1] += s1;
        for (int i = 1; i <= n; i++)
            gap += (m - i) * c[i];
        double dgap = gap;
        where = m + dgap / s2;
        if (where >= n)
            ans = n;
        else if (where <= 1)
            ans = 1;
        else
        {
            int iwhere = where;
            if (iwhere == where)
                ans = iwhere;
            else
            {
                long long ans1 = abs(gap + (m - iwhere) * s2);
                long long ans2 = abs(gap + (m - iwhere - 1) * s2);
                ans = ans1 <= ans2 ? iwhere : iwhere + 1;
            }
        }
        return ans;
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m,p1,s1,s2;
    cin>>n;
    vector<int> c;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        c.push_back(x);
    }
    cin>>m>>p1>>s1>>s2;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,m,p1,s1,s2,c);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",simulate,middle,,,,,,,,,,,,,,,,
luogu8,"A teacher of abacus arithmetic in a certain school used a test method to quickly test the ability of abacus arithmetic addition. He randomly generated a set of positive integers, each with different numbers, and asked the students to answer: How many of these numbers are exactly equal to the sum of two other (different) numbers in the set?
Recently the teacher gave some test questions, please help to find out the answers.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<int> &num)
}
```

Pass in parameters:
1 integer, n.
An array with num containing n positive integers.

Return parameters:
An integer representing the answer to the quiz question

Example 1:
Input: n=4,num=[1, 2, 3, 4]
Output: 2

Restrictions:
3≤n≤@data, 1≤num[i] ≤10000
Time limit: @time_limit ms
Memory limit: @memory_limit KB","某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？
最近老师出了一些测验题，请你帮忙求出答案。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<int> &num)
}
```

传入参数:
1个整数，n。
1个数组，num包含n个正整数。

返回参数:
一个整数 ，表示测验题答案

样例1：
Input：n=4,num=[1, 2, 3, 4]
Output: 2

限制：
3≤n≤@data，1≤num[i]​≤10000
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 20 100,1000,6400 640 64,"class Solution
{
public:
    int solve(int n, vector<int> &num)
    {
        num.insert(num.begin(), 0);
        int m = 0;
        sort(num.begin() + 1, num.begin() + n + 1);
        for (int i = 3; i <= n; i++)
        {
            for (int j = 1; j < i - 1; j++)
            {
                for (int k = j + 1; k < i; k++)
                {
                    if (num[j] + num[k] == num[i])
                    {
                        m++;
                        goto skip;
                    }
                }
            }
        skip:;
        }
        return m;
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<int> num;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,num);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",simulate,middle,,,,,,,,,,,,,,,,
luogu9,"There is a water room in the school, which is equipped with a total of $m$taps for students to turn on the water, and the water supply of each tap is equal to $1 per second.
Now there are $n$students ready to receive water, their initial order of receiving water has been determined. These students are numbered from $1$to $n$in the order of receiving water, and the amount of water received by students with $i$is $w_i$. When receiving water, students from $1$to $m$each occupy a faucet and open the faucet at the same time. When one of the students $j$completes the water demand $w_j$, the next student $k$who waits in line to receive water immediately takes the place of the student $j$and starts to receive water. The replacement process is instantaneous and no water is wasted. That is, when $j$finishes receiving water at the end of $x$second, $k$starts receiving water immediately at $x+1$second. If the current number of people receiving water $n'$is less than $m$, only $n'$tap water supply, other $m - n'$tap closed.
Now give the amount of water received by $n$students, and ask how many seconds it takes for all students to receive water according to the above rules.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &w)
}
```

Pass in parameters:
The two integers are $n and m$, respectively, indicating the number of people receiving water and the number of taps.
1 array, $n$integers $w_1,w_2,\ldots,w_n$, separated by a space between each two integers, $w_i$indicates the amount of water received by the student with $i$

Return parameters:
An integer representing the total time required to connect the water.

Example 1:
Input: n=5,m=3,w=[4, 4, 1, 2, 1]
Output: 4

Example 2:
Input: n=8,m=4,w=[23, 71, 87, 32, 70, 93, 80, 76]
Output: 163

Restrictions:
0<n≤@data, 1≤m≤100, m≤n, 1≤wi≤100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。
现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。
现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &w)
}
```

传入参数:
2个整数，分别是 $n,m$，分别表示接水人数和龙头个数。
1个数组，$n$ 个整数 $w_1,w_2,\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量

返回参数:
一个整数，表示接水所需的总时间。

样例1：
Input：n=5,m=3,w=[4, 4, 1, 2, 1]
Output: 4

样例2：
Input：n=8,m=4,w=[23, 71, 87, 32, 70, 93, 80, 76]
Output: 163

限制：
0<n≤@data，1≤m≤100，m≤n，1≤wi≤100
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 10000,1000,6400 640 64,"class Solution
{
public:
    int solve(int n, int m, vector<int> &w)
    {
        int t = m + 1;
        int ans = 0;
        while (t <= n + m)
        {
            for (int i = 1; i <= m; i++)
            {
                w[i]--;
                if (w[i] == 0)
                {
                    w[i] = w[t];
                    t++;
                }
            }
            ans++;
        }
        return ans;
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;cin>>n>>m;
    vector<int> w;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        w.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,m,w);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",avarice,middle,,,,,,,,,,,,,,,,
luogu10,"Given a permutation of length n, find the MTH permutation after it

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(int n, int m, vector<int> &num)
}
```

Pass in parameters:
2 integers n,m and an array num

Return parameters:
An array represents the answer.

Example 1:
Input: n=5,m=3,num=[1, 2, 3, 4, 5]
Output: ans=[1, 2, 4, 5, 3]

Restrictions:
0<n≤@data, m≤100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个长度为 n 的排列，求他后面的第m个排列

solution内主函数
```cpp
class Solution
{
    public:
    vector<int> solve(int n, int m, vector<int> &num)
}
```

传入参数:
2个整数n,m,一个数组num

返回参数:
一个数组表示答案。

样例1：
Input：n=5,m=3,num=[1, 2, 3, 4, 5]
Output: ans=[1, 2, 4, 5, 3]

限制：
0<n≤@data，m≤100
时间限制：@time_limit ms
内存限制：@memory_limit KB",20 100 10000,1000,6400 640 64,"class Solution
{
public:
    vector<int> solve(int n, int m, vector<int> &num)
    {
    	for(int i=1;i<=m;++i)	next_permutation(num.begin(),num.end());
        return num;
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m; cin>>n>>m;
    vector<int> num;
    for (int i = 1; i <=n; i++)
    {
        int x; cin >> x;
        num.push_back(x);
    }

    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,m,num);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it :num) cout<<it<<' ';

    return 0;
}",STL,middle,,,,,,,,,,,,,,,,
luogu11,"Given a positive integer $k$, the sum of all the powers of $k$and a finite number of unequal powers of $k$forms an increasing sequence, for example, when $k = 3$, the sequence is:
$1, 3, 4, 9, 10, 12, 13, \ldots$
(the sequence is actually: $3 ^ 0, 1, 3 ^ ^ 3 ^ 0 + 1, 2, 3 ^ ^ 0 + 3 ^ 2 or 3 ^ 1 + 3 ^ 2, 3 ^ 0 + 3 ^ 2 + 3 ^ 1,... $)
Find the value of the $N$item in this sequence, expressed in $10$.

solution main function
```cpp
class Solution
{
    public:
    long long solve(int k, int n)
}
```

Pass in parameters:
2 integers, $k,N$.

Return parameters:
An integer representing the answer.

Example 1:
Input k=3,N=100
Output: 981

Restrictions:
k≤ 15,0 <n≤@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给定一个正整数 $k$，把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列，例如，当 $k = 3$ 时，这个序列是：
$1, 3, 4, 9, 10, 12, 13, \ldots$
（该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）
请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。

solution内主函数
```cpp
class Solution
{
    public:
    long long solve(int k, int n)
}
```

传入参数:
2个整数，分别是 $k,N$。

返回参数:
一个整数，表示答案。

样例1：
Input k=3,N=100
Output: 981

限制：
k≤15，0<n≤@data
时间限制：@time_limit ms
内存限制：@memory_limit KB",200 300 1000,1000,6400 640 64,"class Solution
{
public:
    long long solve(int k, int n)
    {
        long long ans,base=1;
        while(n){
            if(n&1)ans+=base;
            base*=k;
            n>>=1;
	    }
        return ans;
    }
};",使用现有数据,"#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int k,N; cin >> k >> N;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(k,N);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",math,middle,,,,,,,,,,,,,,,,
luogu12,"The middle order and post order of a binary tree are given. Find its preordering. (Convention tree nodes are represented by different capital letters).

solution main function
```cpp
class Solution
{
public:
string solve(string mid,string suf)
}
```

Pass in parameters:
Two strings of uppercase letters representing the middle and back order of a binary tree

Return parameters:
A string representing the first order of a binary tree.

Example 1:
Input: mid=""BADC"",suf=""BDCA""
Output: ""ABCD""

Restrictions:
The string length is less than or equal to @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示）。

solution内主函数
```cpp
class Solution
{
    public:
    string solve(string mid,string suf)
}
```

传入参数:
两个均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列

返回参数:
一个字符串，表示二叉树的先序。

样例1：
Input：mid=""BADC"",suf=""BDCA""
Output: ""ABCD""

限制：
字符串长度小于等于@data
时间限制：@time_limit ms
内存限制：@memory_limit KB",3 5 8,1000,6400 640 64,"class Solution
{
public:
    string solve(string mid, string suf)
    {
        if (mid.size() == 0) return """";

        char ch = suf[suf.size() - 1];
        int k = mid.find(ch);

        return string(1, ch) + solve(mid.substr(0, k), suf.substr(0, k)) + solve(mid.substr(k + 1), suf.substr(k, mid.size() - k - 1));
    }
};","#include<bits/stdc++.h>
using namespace std;

struct Node
{
    int l,r,val;
}tre[100010];

int tot=0;
int s[30];
void insert(int &x)
{
    if(x==0)
    {
        x=++tot;
        tre[x].val=s[tot];
        tre[x].l=tre[x].r=0;
        return ; 
    }
    if(rand()&1) insert(tre[x].l);
    else insert(tre[x].r);
}

void indfs(int root, string& mid) {
    if (!root) return;
    indfs(tre[root].l, mid);
    mid.push_back(tre[root].val);
    indfs(tre[root].r, mid);
}

void sufdfs(int root, string& suf) {
    if (!root) return;
    sufdfs(tre[root].l, suf);
    sufdfs(tre[root].r, suf);
    suf.push_back(tre[root].val);
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    srand(time(0)); // 用当前时间作为随机数种子
    int n=data;
    for(int i=1;i<=26;i++) s[i]=i-1+'A';
    random_shuffle(s+1,s+27);
    int root=++tot; tre[1].val=s[1];
    for(int i=1;i<=n;i++) insert(root);
    string mid, suf;
    indfs(root, mid);
    sufdfs(root, suf);

    cout<<mid<<endl<<suf;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    string mid,suf;cin>>mid>>suf;

    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(mid,suf);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",simulate,easy,,,,,,,,,,,,,,,,
luogu13,"There is a row of $N$coins on the table, and each coin is heads up. Now to flip all the coins tails up, the rule is that you can flip any $N- $1 coin at a time (heads up are flipped tails up and vice versa). Find the shortest sequence of operations (turning each flip of $N-1 coin into one operation).

solution main function
```cpp
class Solution
{
    public:
    pair< int,vector<string> > solve(int n)
}
```

Pass in parameters:
An even natural number $n$.

Return parameters:
An integer represents the minimum number of operations required.
A vector<string> array that stores the state of the coins on the table after each operation (a row containing $N$integers $0$or $1$, representing the state of each coin, $0$representing heads up and $1$representing tails up). The output of redundant Spaces is not allowed.
In cases where there are multiple operation options, only the lexicographic order of the operation needs to output a minimum of one.
The lexicographic order of operations means that for each position in an operation, $1$means flip and $0$means no flip.
But what you need to output is the state after each operation, $0$means heads up, $1$means tails up.

Example 1:
Input: n=4
Output: (4,[""0111"", ""1100"", ""0001"", ""1111""])

Restrictions:
0<n≤@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。

solution内主函数
```cpp
class Solution
{
    public:
    pair< int,vector<string> > solve(int n)
}
```

传入参数:
一个自然数偶数 $n$。

返回参数:
一个整数表示最少需要的操作次数。
一个vector<string>数组，存储着每次操作后桌上硬币的状态（一行包含 $N$ 个整数 $0$ 或 $1$，表示每个硬币的状态，$0$ 表示正面向上，$1$ 表示反面向上。不允许输出多余空格。
对于有多种操作方案的情况，则只需操作的字典序最小输出一种。
操作的字典序是指，对于一次操作中的每个位置，$1$ 表示翻转，$0$ 表示不反转。
但是需要你输出的是每一次操作完的状态，$0$ 表示正面朝上，$1$ 表示反面朝上。

样例1：
Input：n=4
Output: (4,[""0111"", ""1100"", ""0001"", ""1111""])

限制：
0<n≤@data
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 50 100,1000,6400 640 64,"class Solution
{
public:
    pair< int,vector<string> > solve(int n)
    {
        vector<string> ans;
        for (int i=1;i<=n;i++){
            string s;
            for (int j=1;j<=i;j++) s.push_back(48|~i&1);
            for (int j=i+1;j<=n;j++) s.push_back(48|i&1);
            ans.push_back(s);
        }
        return {n,ans};
    }
};","#include<bits/stdc++.h>
using namespace std;
int main(int argc, char* argv[]) {
    srand(time(0));
    int data = std::atoi(argv[1]);
    if(data<=10) cout<<data;
    else cout<<data-10+rand()%5*2;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result.first<<endl;
    for(auto it:result.second)
        cout<<it<<endl;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
luogu14,"Yangtze River Yacht Club set up $n$yacht rental station on the Yangtze River $1,2,\cdots,n$. Visitors can hire their yacht at these yacht hire stations and return it at any of the yacht hire stations downstream. The rental between the yacht rental station $i$and the yacht rental station $j$is $r(i,j)$($1\le i\lt j\le n$). Try to design an algorithm to calculate the minimum rental required from the yacht rental station $1 to the yacht rental station $n$.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int> >&r)
}
```

Pass in parameters:
1 integer n.
A two-dimensional vector array $n-1$row is a semi-matrix $r(i,j)$($1\le i<j\le n$)

Return parameters:
An integer representing the minimum rental required from the yacht rental station $1 to the yacht rental Station $n$.

Example 1:
Input: n=3,r=[[5, 15], [7]]
Output: 12

Restrictions:
0<n≤@data,r(i,j)≤1000
Time limit: @time_limit ms
Memory limit: @memory_limit KB","长江游艇俱乐部在长江上设置了 $n$ 个游艇出租站 $1,2,\cdots,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 $i$ 到游艇出租站 $j$ 之间的租金为 $r(i,j)$（$1\le i\lt j\le n$）。试设计一个算法，计算出从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int> >&r)
}
```

传入参数:
1个整数n。
一个二维vector数组 $n-1$ 行是一个半矩阵 $r(i,j)$（$1\le i<j\le n$）

返回参数:
一个整数，表示从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

样例1：
Input：n=3,r=[[5, 15], [ 7]]
Output: 12

限制：
0<n≤@data,r(i,j)≤1000
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution
{
public:
    int solve(int n, vector<vector<int> >&r)
    {
		int f[n+1];
		for(int i=0;i<=n;i++) f[i]=0;
		for (int i=1;i<=n;i++)
			for (int j=i+1;j<=n;j++)
			{
				if (f[j]==0||f[j]>f[i]+r[i-1][j-i-1]) //如果j还没有到过或者到j的距离比原来短
					f[j]=f[i]+r[i-1][j-i-1]; //替换
			}
	return f[n];
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n = rng(1, data); cout<<n<<endl;
    for(int i=n-1;i>=1;i--)
    {
        for(int j=1;j<=i;j++)
            cout<<rng(1,1000)<<' ';
        cout<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin >> n;
    vector<vector<int> > r;
    for(int i=1;i<n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=n-i;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        r.push_back(temp);
    }

    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,r);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,middle,,,,,,,,,,,,,,,,
leetcode1,"Child A is playing a message game with his friends. The rules of the game are as follows:
There are n players, all of whom are numbered from 0 to n-1, and child A is numbered 0
Each player has a fixed number of other players to whom information can be transmitted (or not). The information transfer relationship is one-way (for example, A can send information to B, but B cannot send information to A).
Each round of information must need to be passed to another person, and the information can be repeated through the same person
Given the total number of players n, and the two-dimensional array relation formed by the [player number, corresponding to the passable player number] relation. Returns the number of schemes passed from minor A (number 0) to the small partner (number n-1) after k rounds; If it cannot be reached, return 0.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& relation, int k)
}
```

Example 1:
Input: n = 5, base = [[0, 2], [2, 1], [3, 4], [2, 3], [1, 4], [2, 0], [0, 4]], k = 3
Output: 3

Example 2:
Input: n = 3, relation = [[0,2],[2,1]], k = 2
Output: 0

Restrictions:

2 <= n <= @data
1 <= k <= @data

1 <= relation.length <= 10*@data, and relation[i].length == 2
0 <= relation[i][0],relation[i][1] < n and relation[i][0]! = relation[i][1]
Time limit: @time_limit ms
Memory limit: @memory_limit KB","小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
    有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
    每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
    每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& relation, int k)
}
```

样例1：
Input：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
Output: 3

样例2：
Input：n = 3, relation = [[0,2],[2,1]], k = 2
Output: 0

限制：

2 <= n <= @data
1 <= k <= @data

1 <= relation.length <= 10*@data, 且 relation[i].length == 2
0 <= relation[i][0],relation[i][1] < n 且 relation[i][0] != relation[i][1]
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution {
public:
    int solve(int n, vector<vector<int>>& relation, int k) {
        vector<int> dp(n);
        dp[0] = 1;
        for (int i = 0; i < k; i++) {
            vector<int> next(n);
            for (auto& edge : relation) {
                int src = edge[0], dst = edge[1];
                next[dst] += dp[src];
            }
            dp = next;
        }
        return dp[n - 1];
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;
    std::cout<<n<<' '<<m<<'\n';

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = f[std::make_pair(i, p)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x  << "" "" << y  << ""\n"";
    }
}
using namespace std;
int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    // int data=20;
    int n = rng(data-10, data);
    if(n<=10)
    {
        cout<<n<<' '<<n*(n-1)/2<<endl;
        for(int i=1;i<=n;i++)
            for(int j=1;j<i;j++)
                cout<<i<<' '<<j<<endl;
        cout<<rand()%n+1;
        return 0;
    }
    int m = 4*n;
    graph(n,m);
    cout<<rng(1,n);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m,k; cin>>n>>m;
    vector< vector<int> > relation;
    for(int i=1,x,y;i<=m;i++)
    {
        cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        relation.push_back(temp);
    }
    cin>>k;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,relation,k);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,middle,,,,,,,,,,,,,,,,
leetcode2,"There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.
solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& edges)
}
```

Example 1:
Input: edges = [[1,2],[2,3],[4,2]]
Output: 2

Restrictions:

2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui ! = vi
Time limit: @time_limit ms
Memory limit: @memory_limit KB","有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。
给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& edges)
}
```

样例1：
Input：edges = [[1,2],[2,3],[4,2]]
Output: 2

限制：

2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 100000,1000,6400 640 64,"class Solution {
public:
    int solve(vector<vector<int>>& edges) {
        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n = rng(data-10, data);
    cout<<n<<endl;
    int p=rng(1,n);
    for(int i=1;i<=n;i++)
        if(i!=p)
            cout<<i<<' '<<p<<endl;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    vector<vector<int> > edge;
    for(int i=1;i<n;i++)
    {
        int x,y;cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(edge);
    get_usage(argv[0], argv[1]);

    // output
    cout << result << ""\n"";

    return 0;
}",tree,easy,,,,,,,,,,,,,,,,
leetcode7,"You are given an integer array prices where prices[i] is the price of the ith item in a shop.
There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.
Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(vector<int>& prices)
}
```

Example 1:
Input：prices = [8,4,6,2,3]
Output: [4,2,4,2,3]

Example 2:
Input：prices = [1,2,3,4,5]
Output: [1,2,3,4,5]

Restrictions:
1 <= prices.length <= @data
1 <= prices[i] <= 10^3
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。
请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。

solution内主函数
```cpp
class Solution
{
    public:
    vector<int> solve(vector<int>& prices)
}
```

样例1：
Input：prices = [8,4,6,2,3]
Output: [4,2,4,2,3]

样例2：
Input：prices = [1,2,3,4,5]
Output: [1,2,3,4,5]

限制：
1 <= prices.length <= @data
1 <= prices[i] <= 10^3
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 1000 10000,1000,6400 640 64,"class Solution {
public:
    vector<int> solve(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans(n);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && st.top() > prices[i]) {
                st.pop();
            }
            ans[i] = st.empty() ? prices[i] : prices[i] - st.top();
            st.emplace(prices[i]);
        }
        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(1,data-10),data);
    std:: cout<<n<<'\n';
    array(n,1000);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<int> price;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        price.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(price);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result) cout<<it<<' ';

    return 0;
}",Monotone stack,middle,"class Solution {
public:
    vector<int> solve(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            int discount = 0;
            for (int j = i + 1; j < n; ++j) {
                if(prices[j] <= prices[i]){
                    discount = prices[j];
                    break;
                }
            }
            ans.emplace_back(prices[i] - discount);
        }
        return ans;
    }
};",,,,,,,,,,,,,,,
leetcode8,"You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.
Return the minimum size of the set so that at least half of the integers of the array are removed.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<int>& arr)
}
```

Example 1:
Input：arr = [3,3,3,3,5,5,5,2,2,7]
Output: 2

Example 2:
Input：arr = [7,7,7,7,7,7]
Output: 1

Restrictions:
1 <= arr.length <= @data
arr.length is even.
1 <= arr[i] <= 10^5
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。
返回 至少 能删除数组中的一半整数的整数集合的最小大小。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<int>& arr)
}
```

样例1：
Input：arr = [3,3,3,3,5,5,5,2,2,7]
Output: 2

样例2：
Input：arr = [7,7,7,7,7,7]
Output: 1

限制：
1 <= arr.length <= @data
arr.length 为偶数
1 <= arr[i] <= 10^5
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 1000 10000,1000,6400 640 64,"class Solution {
public:
    int solve(vector<int>& arr) {
        sort(arr.begin(),arr.end());
        vector<int> arr_freq;
        arr_freq.push_back(1);
        int cir_freq = 0;
        for(int i=0;i<arr.size()-1;i++){
            if(arr[i]!=arr[i+1]){
                arr_freq.push_back(1);
                cir_freq++;
            }
            else{
                arr_freq[cir_freq] += 1;
            }
        }
        sort(arr_freq.begin(),arr_freq.end());
        int res = 0;
        int res_size = arr.size();
        for(int i=arr_freq.size()-1;i>=0;i--){
            if(res_size>arr.size()/2){
                res++;
                res_size -= arr_freq[i];
            }
            else{
                break;
            }
        }
        return res;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=data; if(n&1) n--;
    std:: cout<<n<<'\n';
    array(n,std::max(10,n/10));
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<int> arr;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        arr.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(arr);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;

    return 0;
}",avarice,middle,,,,,,,,,,,,,,,,
leetcode9,"There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].
The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.
    For example, the correct password is ""345"" and you enter in ""012345"":
        After typing 0, the most recent 3 digits is ""0"", which is incorrect.
        After typing 1, the most recent 3 digits is ""01"", which is incorrect.
        After typing 2, the most recent 3 digits is ""012"", which is incorrect.
        After typing 3, the most recent 3 digits is ""123"", which is incorrect.
        After typing 4, the most recent 3 digits is ""234"", which is incorrect.
        After typing 5, the most recent 3 digits is ""345"", which is correct and the safe unlocks.
Return any string of minimum length that will unlock the safe at some point of entering it.

solution main function
```cpp
class Solution
{
    public:
    string solve(int n, int k)
}
```
Example 1:
Input：n = 1, k = 2
Output: ""10""

Example 2:
Input：n = 2, k = 2
Output: ""01100""

Restrictions:
1 <= n <= 4
1 <= k <= @data
1 <= k^n <= 4096
Time limit: @time_limit ms
Memory limit: @memory_limit KB","有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。
保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。
    例如，正确的密码是 ""345"" ，并且你输入的是 ""012345"" ：
        输入 0 之后，最后 3 位输入是 ""0"" ，不正确。
        输入 1 之后，最后 3 位输入是 ""01"" ，不正确。
        输入 2 之后，最后 3 位输入是 ""012"" ，不正确。
        输入 3 之后，最后 3 位输入是 ""123"" ，不正确。
        输入 4 之后，最后 3 位输入是 ""234"" ，不正确。
        输入 5 之后，最后 3 位输入是 ""345"" ，正确，打开保险箱。
在只知道密码位数 n 和范围边界 k 的前提下，请你找出并返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列 。

solution内主函数
```cpp
class Solution
{
    public:
    string solve(int n, int k)
}
```

样例1：
Input：n = 1, k = 2
Output: ""10""

样例2：
Input：n = 2, k = 2
Output: ""01100""

限制：
1 <= n <= 4
1 <= k <= @data
1 <= k^n <= 4096
时间限制：@time_limit ms
内存限制：@memory_limit KB",3 5 10,1000,6400 640 64,"class Solution {
public:
    string solve(int n, int k) {
        int nodeNum = pow(k, n - 1);
        int nedge = pow(k, n);
        std::vector<int> vecNode(nodeNum, k - 1); // 每个节点当前的当前的出边的值
        std::string strret(nedge + (n - 1), '0'); // 初始化为00+0...
        for (int i = n - 1, idx = 0; i < strret.length(); ++i) {
            int& curedge = vecNode[idx];
            strret[i] = curedge + '0';
            idx = (idx * k + curedge) % nodeNum;
            --curedge;
        }
        return strret;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(2,4),k=data;
    std::cout<<n<<' '<<k;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,k;
    cin>>n>>k;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,k);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result) cout<<it<<' ';

    return 0;
}",graph,hard,,,,,,,,,,,,,,,,
leetcode10,"There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.
A critical connection is a connection that, if removed, will make some servers unable to reach some other server.
Return all critical connections in the network in any order.

solution main function
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& connections)
}
```


Example 1:
Input：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]

Example 2:
Input：n = 2, connections = [[0,1]]
Output: [[0,1]]

Restrictions:
2 <= n <= @data
n - 1 <= connections.length <= 10^5
0 <= a[i], b[i] <= n - 1
a[i] != b[i]
Time limit: @time_limit ms
Memory limit: @memory_limit KB","力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以 服务器到服务器 的形式相互连接组成了一个内部集群，连接是无向的。用  connections 表示集群网络，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。
关键连接 是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。
请你以任意顺序返回该集群内的所有 关键连接 。

solution内主函数
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& connections)
}
```

样例1：
Input：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]

样例2：
Input：n = 2, connections = [[0,1]]
Output: [[0,1]]

限制：
2 <= n <= @data
n - 1 <= connections.length <= 10^5
0 <= a[i], b[i] <= n - 1
a[i] != b[i]
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 10000,1000,6400 640 64,"class Solution {
public:
    vector<vector<int> > solve(int n, vector<vector<int> >& connections) {
        vector<vector<int>> dict(n);
        for(auto& edge:connections){
            dict[edge[0]].emplace_back(edge[1]);
            dict[edge[1]].emplace_back(edge[0]);
        }
        vector<int> id(n, -1);
        vector<vector<int>> res;
        dfs(0, 0, -1, id, dict, res);
        return res;
    }

    // Tarjan's算法，将整个环统合为一个节点
    int dfs(int node, int nodeId, int par, vector<int>& id, vector<vector<int>>& dict, vector<vector<int>>& res){
        // 先使用深度搜索来确认环的存在
        id[node] = nodeId; // 正常继承递增的编号
        for(int next:dict[node]){
            // f防止重复搜索
            if(next == par) continue;
            // 更新编号为环中最小的那个
            else if(id[next] == -1) id[node] = min(id[node], dfs(next, nodeId+1, node, id, dict, res));
            else id[node] = min(id[next], id[node]);
        }
        // node不能是0，因为不存在-1的家长，id[node] == nodeId意味着不在环中的连接（node为环中的最小编号节点而par自然不在环里）
        if(id[node] == nodeId && node != 0) res.push_back({par, node});
        return id[node];
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = f[std::make_pair(i, p)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x  << "" "" << y  << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    long long n=rng(std::max(10,data-10),data);
    long long m=rng(1,std::min(n*(n-1)/2,3ll*n));
    graph(n, m);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > edge;
    for(int i=1;i<=m;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,edge);
    get_usage(argv[0], argv[1]);

    // output
    sort(result.begin(),result.end());
    for(auto it:result)
    {
        int x=it[0];
        int y=it[1];
        if(x>y) swap(x,y);
        cout<<x<<' '<<y<<' ';
    }
    return 0;
}",graph,hard,,,,,,,,,,,,,,,,
leetcode11,"Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [a_i, b_i, weight_i] represents a bidirectional and weighted edge between nodes a_i and b_i. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

solution main function
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& edges)
}
```

Example 1:
Input：n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]

Example 2:
Input：n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]

Restrictions:
2 <= n <= @data
1 <= edges.length <= min(4*n, n * (n - 1) / 2)
edges[i].length == 3
0 <= from_i < to_i < n
1 <= weight_i <= 1000
All pairs (a_i, b_i) are distinct
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [from_i, to_i, weight_i] 表示在 from_i 和 to_i 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。
请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。
请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。

solution内主函数
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& edges)
}
```

样例1：
Input：n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]

样例2：
Input：n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]

限制：
2 <= n <= @data
1 <= edges.length <= min(4*n, n * (n - 1) / 2)
edges[i].length == 3
0 <= from_i < to_i < n
1 <= weight_i <= 1000
所有 (from_i, to_i) 数对都是互不相同的。
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution {
public:

    int p[1010];


    int find(int a) {
        if (a != p[a]) p[a] = find(p[a]);
        return p[a];
    }

    int work1(int n, vector<vector<int>>& edges, int k) { // 不选第k条边的最小生成树的权重
        for (int i = 0; i < n; i ++ ) p[i] = i;
        int cost = 0, cnt = 0;
        for (auto& e:edges) {
            if (e[3] == k) continue;  //  如果是第k条边，则跳过
            int f1 = find(e[1]), f2 = find(e[2]);
            if (f1 != f2) {
                cost += e[0];
                cnt ++;
                if (cnt == n - 1) break;
                p[f1] = f2;
            }
        }
        if (cnt == n - 1) return cost;
        else return INT_MAX;
    }

    int work2(int n, vector<vector<int>>& edges, int k) { // 一定选第k条边的最小生成树的权重
        for (int i = 0; i < n; i ++ ) p[i] = i;
        int cost = 0, cnt = 0;

        for (auto& e : edges) {  // 先向第k条边加入到集合中
            if (e[3] == k) {
                cost += e[0];
                cnt ++;
                p[e[1]] = e[2];
                break;
            }
        }

        for (auto& e: edges) {
            int f1 = find(e[1]), f2 = find(e[2]);
            if (f1 != f2) {
                cost += e[0];
                cnt ++;
                if (cnt == n - 1) break;
                p[f1] = f2;
            }
        }
        if (cnt == n - 1) return cost;
        else return INT_MAX;
    }

    vector<vector<int>> solve(int n, vector<vector<int>>& edges) {

        int m = edges.size();
        for (int i = 0; i < m; i ++ ) {
            auto& e = edges[i];
            swap(e[0], e[2]);
            e.push_back(i);
        }
        sort(edges.begin(), edges.end());

        int min_cost = work1(n, edges, -1);   // 求出最小生成树权重
        // cout << min_cost << endl;
        vector<vector<int>> ans(2);
        for (int i = 0; i < m; i ++ ) {
            if (work1(n, edges, i) > min_cost) ans[0].push_back(i);  // 判断是否为关键边
            else if (work2(n, edges, i) == min_cost) ans[1].push_back(i);  // 判断是否为伪关键边
        } 
        return ans;

    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = f[std::make_pair(i, p)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x  << "" "" << y <<' '<< (rnd()%1000+1) << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    long long n=rng(std::max(10,data-10),data);
    long long m=rng(1,std::min(n*(n-1)/2,4ll*n));
    graph(n, m);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > edge;
    for(int i=1;i<=m;i++)
    {
        int x,y,z; cin>>x>>y>>z;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,edge);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result)
    {
        sort(it.begin(),it.end());
        for(auto x:it)
            cout<<x<<' ';
        cout<<endl;
    }
    return 0;
}",graph,hard,,,,,,,,,,,,,,,,
leetcode12,"You are given an m * n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.
The grid is said to be connected if we have exactly one island, otherwise is said disconnected.
In one day, we are allowed to change any single land cell (1) into a water cell (0).
Return the minimum number of days to disconnect the grid.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```
Example 1:
Input：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Output: 2

Example 2:
Input：grid = [[1,1]]
Output: 2

Restrictions:
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] is either 0 or 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个大小为 m * n ，由若干 0 和 1 组成的二维网格 grid ，其中 1 表示陆地， 0 表示水。岛屿 由水平方向或竖直方向上相邻的 1 （陆地）连接形成。
如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。
一天内，可以将 任何单个 陆地单元（1）更改为水单元（0）。
返回使陆地分离的最少天数。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```

样例1：
Input：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Output: 2

样例2：
Input：grid = [[1,1]]
Output: 2

限制：
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] 为 0 或 1
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 30 50,1000,6400 640 64,"class Solution {
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};
public:
    void dfs(int x, int y, vector<vector<int>>& grid, int n, int m) {
        grid[x][y] = 2;
        for (int i = 0; i < 4; ++i) {
            int tx = dx[i] + x;
            int ty = dy[i] + y;
            if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] != 1) {
                continue;
            }
            dfs(tx, ty, grid, n, m);
        }
    }
    int count(vector<vector<int>>& grid, int n, int m) {
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    cnt++;
                    dfs(i, j, grid, n, m);
                }
            }
        }
        // 还原
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 2) {
                    grid[i][j] = 1;
                }
            }
        }
        return cnt;
    }
    int solve(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        // 岛屿数量不为 1，陆地已经分离
        if (count(grid, n, m) != 1) {
            return 0;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j]) {
                    grid[i][j] = 0;
                    if (count(grid, n, m) != 1) {
                        // 更改一个陆地单元为水单元后陆地分离
                        return 1;
                    }
                    grid[i][j] = 1;
                }
            }
        }
        return 2;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(10,data-10),data);
    int m=rng(std::max(10,data-10),data);
    std::cout<<n<<' '<<m<<'\n';
    for(int i=1;i<=n;i++)
    {
        for(int i=1;i<=m;i++)
        {
            if(rnd()%4) std::cout<<1<<' ';
            else std::cout<<0<<' ';
        }
        putchar('\n');
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        g.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(g);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,hard,,,,,,,,,,,,,,,,
leetcode13,"There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].
A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).
Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(vector<vector<int>>& graph)
}
```

Example 1:
Input：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]

Example 2:
Input：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]

Restrictions:
n == graph.length
1 <= n <= @data
0 <= graph[i].length <= n
0 <= graph[i][j] <= n - 1
graph[i] is sorted in a strictly increasing order.
The graph may contain self-loops.
The number of edges in the graph will be in the range [1, 4 * n].
Time limit: @time_limit ms
Memory limit: @memory_limit KB","有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。
如果一个节点没有连出的有向边，则该节点是 终端节点 。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。
返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。

solution内主函数
```cpp
class Solution
{
    public:
    vector<int> solve(vector<vector<int>>& graph)
}
```

样例1：
Input：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]

样例2：
Input：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]

限制：
n == graph.length
1 <= n <= @data
0 <= graph[i].length <= n
0 <= graph[i][j] <= n - 1
graph[i] 按严格递增顺序排列。
图中可能包含自环。
图中边的数目在范围 [1, 4 * n] 内
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 10000,1000,6400 640 64,"class Solution {
public:
    vector<int> solve(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<bool> vis(n);
        vector<bool> safe(n);
        auto dfs = [&](auto dfs, int u) -> void {
            vis[u] = true;
            for(int v : graph[u]) {
                if(!vis[v]) { // 未访问过
                    dfs(dfs, v);
                    if(!safe[v]) { // 若不确定安全
                        safe[u] = false;
                        return ;
                    }
                } else if(!safe[v]) { // 已访问过且确定不安全
                    safe[u] = false;
                    return ;
                }
            }
            // 确定安全
            safe[u] = true;
        };

        for(int i = 0;i < n;i ++) {
            if(!vis[i]) dfs(dfs, i);
        }
        vector<int> ans;
        for(int i = 0;i < n;i ++) {
            if(safe[i]) ans.push_back(i);
        }
        return move(ans);
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++) {
        int p = rng(0, i - 1);
        e.push_back(std::make_pair(p, i));
        f[std::make_pair(p, i)] = true;
    }

    // debug(f);
    for (int i = n; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while ( f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x << "" "" << y << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=data;
    int m=4*data;
    graph(n,m);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    vector<int> e[n+1];
    for(int i=1;i<=m;i++)
    {
        int x,y; cin>>x>>y;
        e[x].push_back(y);
    }
    for(int i=0;i<n;i++)
        g.push_back(e[i]);
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(g);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result)
        cout<<it<<' ';
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode14,"You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.
Return the number of complete connected components of the graph.
A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.
A connected component is said to be complete if there exists an edge between every pair of its vertices.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```

Example 1:
Input：n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
Output: 3

Example 2:
Input：n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
Output: 1

Restrictions:
1 <= n <= @data
0 <= edges.length <= 3*n
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
There are no repeated edges.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数 n 。现有一个包含 n 个顶点的 无向 图，顶点按从 0 到 n - 1 编号。给你一个二维整数数组 edges 其中 edges[i] = [ai, bi] 表示顶点 ai 和 bi 之间存在一条 无向 边。
返回图中 完全连通分量 的数量。
如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 连通分量 。
如果连通分量中每对节点之间都存在一条边，则称其为 完全连通分量 。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```

样例1：
Input：n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
Output: 3

样例2：
Input：n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
Output: 1

限制：
1 <= n <= @data
0 <= edges.length <= 3*n
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
不存在重复的边
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 10000,1000,6400 640 64,"class Solution {
public:
    int find(vector<int>& G, int n)
    {
        while (G[n] >= 0){
            n = G[n];
        }
        return n;
    }

    int solve(int n, vector<vector<int>>& edges) {
        vector<int> G(n,-1);
        vector<int> edge(n,0);
        int cnt = 0;
        for (int i=0; i<edges.size(); i++){
            int r1 = find(G,edges[i][0]);
            int r2 = find(G,edges[i][1]);
            int t1 = fmin(r1,r2), t2 = fmax(r1,r2);
            r1 = t1;
            r2 = t2;
            if (r1 != r2){
                G[r1] += G[r2];
                G[r2] = r1;
                edge[r1] += edge[r2];
            }
            edge[r1]++;
        }
        for (int i=0; i<n; i++){
            if (G[i] < 0 && G[i] < 0 && edge[i] == (-G[i]-1)*(-G[i])/2){
                cnt++;
            }
        }
        return cnt;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<int, int>> e;
    std::map<std::pair<int, int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    // debug(f);
    for (int i = 1; i <= m; i++) {
        int x, y;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
        } while (x == y || f.count(std::make_pair(x, y)));

        e.push_back(std::make_pair(x, y));
        f[std::make_pair(x, y)] = f[std::make_pair(y, x)] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        std::cout << x << "" "" << y << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=data;
    int m=2*data;
    graph(n,m);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=m;i++)
    {
        vector<int> temp;
        int x,y; cin>>x>>y;
        temp.push_back(x);
        temp.push_back(y);
        g.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,g);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode15,"You are given an m * n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.
A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.
Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```
Example 1:
Input：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3

Example 2:
Input：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0

Restrictions:
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] is either 0 or 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个大小为 m * n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```

样例1：
Input：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3

样例2：
Input：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0

限制：
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] 的值为 0 或 1
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution 
{   
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int m,n;
public:
    int solve(vector<vector<int>>& grid) 
    {   
        int ret = 0;
        m = grid.size(),n = grid[0].size();
        queue<pair<int,int>>q;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(grid[i][j] == 1)
                {
                    if(i == 0 || j == 0 || i == m - 1 || j == n - 1)
                    {   
                        q.push({i, j});
                        grid[i][j] = 2;
                    }
                }


        while(q.size())
        {
            auto [a,b] = q.front();
            q.pop();
            for(int i = 0;i<4;i++)
            {
                int x = a+dx[i],y = b+dy[i];
                if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==1) q.push({x,y}),grid[x][y] = 2;
            }
        }

       for(int i = 0;i<m;i++)
            for(int j = 0;j<n;j++)
                if(grid[i][j] == 1) ret++;

        return ret;
    }
};","#include<bits/stdc++.h>
using ll = long long;

std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(10,data-10),data);
    int m=rng(std::max(10,data-10),data);
    std::cout<<n<<' '<<m<<'\n';
    for(int i=1;i<=n;i++)
    {
        for(int i=1;i<=m;i++)
        {
            if(rnd()%3) std::cout<<1<<' ';
            else std::cout<<0<<' ';
        }
        putchar('\n');
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        g.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(g);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode16,"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& points)
}
```

Example 1:
Input：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20

Example 2:
Input：points = [[3,12],[-2,5],[-4,1]]
Output: 18

Restrictions:
1 <= points.length <= @data
-10^6 <= xi, yi <= 10^6
All pairs (xi, yi) are distinct.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。
请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& points)
}
```

样例1：
Input：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20

样例2：
Input：points = [[3,12],[-2,5],[-4,1]]
Output: 18

限制：
1 <= points.length <= @data
-10^6 <= xi, yi <= 10^6
所有点 (xi, yi) 两两不同。
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution {
public:
    int solve(vector<vector<int>>& points) {
        int n = points.size();
        vector<bool> visited(n, false); // To track visited nodes
        vector<int> minDist(n, INT_MAX); // Min distance to the MST for each node

        minDist[0] = 0; // Start with the first point
        int result = 0; // Total cost

        for (int i = 0; i < n; ++i) {
            int minCost = INT_MAX;
            int currentNode = -1;

            // Find the next node with the minimum cost to add to the MST
            for (int j = 0; j < n; ++j) {
                if (!visited[j] && minDist[j] < minCost) {
                    minCost = minDist[j];
                    currentNode = j;
                }
            }

            // Add the selected node to the MST
            visited[currentNode] = true;
            result += minCost;

            // Update the minimum distances for the remaining nodes
            for (int j = 0; j < n; ++j) {
                if (!visited[j]) {
                    int dist = abs(points[currentNode][0] - points[j][0]) +
                               abs(points[currentNode][1] - points[j][1]);
                    minDist[j] = min(minDist[j], dist);
                }
            }
        }

        return result;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(10,data-10),data);
    cout<<n<<endl;
    map<pair<int,int>,bool> mp;
    for(int i=1;i<=n;i++)
    {
        int x=rng(-1e6,1e6);
        int y=rng(-1e6,1e6);
        while(mp.find({x,y})!=mp.end())
        {
            x=rng(-1e6,1e6);
            y=rng(-1e6,1e6);
        }
        mp.insert({{x,y},true});
        cout<<x<<' '<<y<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        int x,y; cin>>x>>y;
        temp.push_back(x);
        temp.push_back(y);
        g.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(g);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode17,"You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.
An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.
Return the number of islands in grid2 that are considered sub-islands.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2)
}
```

Example 1:
Input：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3

Example 2:
Input：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2

Restrictions:
m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= @data
grid1[i][j] and grid2[i][j] are either 0 or 1.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
请你返回 grid2 中 子岛屿 的 数目 。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2)
}
```

样例1：
Input：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3

样例2：
Input：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2

限制：
m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= @data
grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 500,1000,6400 640 64,"class Solution {
public:
    int solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int m = grid1.size(), n = grid1[0].size();
        int count = 0;

        // Helper function for DFS
        auto dfs = [&](int x, int y, auto& dfs) -> bool {
            // If out of bounds or water in grid2, stop
            if (x < 0 || y < 0 || x >= m || y >= n ) {
                return true;
            }
            if( grid2[x][y] == 0) return true;
            // Mark the cell as visited in grid2
            grid2[x][y] = 0;

            // Check if the current cell is part of a sub-island
            bool isSubIsland = grid1[x][y] == 1;

            // Explore all 4 directions
            isSubIsland &= dfs(x + 1, y, dfs);
            isSubIsland &= dfs(x - 1, y, dfs);
            isSubIsland &= dfs(x, y + 1, dfs);
            isSubIsland &= dfs(x, y - 1, dfs);

            return isSubIsland;
        };

        // Iterate through all cells in grid2
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                // If it's an unvisited land cell in grid2, perform DFS
                if (grid2[i][j] == 1) {
                    if (dfs(i, j, dfs)) {
                        ++count;
                    }
                }
            }
        }

        return count;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int g[1010][1010];
int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(10,data-10),data);
    int m=rng(std::max(10,data-10),data);
    cout<<n<<' '<<m<<endl;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(rnd()%3) g[i][j]=1;
            else g[i][j]=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cout<<g[i][j]<<' ';
        cout<<endl;
    }
    int lim=rng(n/2,n);
    for(int i=1;i<=lim;i++)
    {
        int x=rng(1,n);
        int y=rng(1,m);
        g[x][y]^=1;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cout<<g[i][j]<<' ';
        cout<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g1,g2;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x; 
            temp.push_back(x);
        }
        g1.push_back(temp);
    }
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x; 
            temp.push_back(x);
        }
        g2.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(g1,g2);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode18,"On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.
A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.
Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& stones)
}
```

Example 1:
Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5

Example 2:
Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3

Restrictions:
1 <= stones.length <= @data
0 <= xi, yi <= 10^4
No two stones are at the same coordinate point.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。
给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& stones)
}
```

样例1：
Input：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5

样例2：
Input：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3

限制：
1 <= stones.length <= @data
0 <= xi, yi <= 10^4
不会有两块石头放在同一个坐标点上
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 10000,1000,6400 640 64,"class Solution {
public:
    // DFS用于查找每一个连通块
    void dfs(int i, vector<vector<int>>& stones, vector<bool>& visited) {
        visited[i] = true;
        // 遍历所有石头，查找是否在同一行或同一列
        for (int j = 0; j < stones.size(); ++j) {
            if (!visited[j] && (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])) {
                dfs(j, stones, visited); // 如果是连通的，则继续DFS
            }
        }
    }

    int solve(vector<vector<int>>& stones) {
        int size = stones.size(); // 石头数量
        vector<bool> visited(size, false); // 访问标记
        int count = 0; // 连通块的数量

        // 遍历每个石头，找到所有连通块
        for (int i = 0; i < size; i++) {
            if (!visited[i]) { // 如果这个石头未被访问过
                dfs(i, stones, visited); // 从这个石头开始DFS
                count++; // 每找到一个连通块，就增加count
            }
        }

        return size - count; // 移除的石头数量 = 总石头数量 - 连通块数量
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=rng(std::max(10,data-10),data);
    int lim=pow(n,0.66666);
    map<pair<int,int>,bool > mp;
    cout<<n<<endl;
    for(int i=1;i<=n;i++)
    {
        int x=rng(1,lim);
        int y=rng(1,lim);
        while(mp.find({x,y})!=mp.end())
        {
            x=rng(1,lim);
            y=rng(1,lim);
        }
        mp.insert({{x,y},true});
        cout<<x<<' '<<y<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<vector<int> > stones;
    for(int i=1;i<=n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        stones.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(stones);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode19,"Alice and Bob have an undirected graph of n nodes and three types of edges:
    Type 1: Can be traversed by Alice only.
    Type 2: Can be traversed by Bob only.
    Type 3: Can be traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.
Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```
Example 1:
Input：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2

Example 2:
Input：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0

Restrictions:
1 <= n <= @data
1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)
edges[i].length == 3
1 <= typei <= 3
1 <= ui < vi <= n
All tuples (typei, ui, vi) are distinct.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：
    类型 1：只能由 Alice 遍历。
    类型 2：只能由 Bob 遍历。
    类型 3：Alice 和 Bob 都可以遍历。
给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。
返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```

样例1：
Input：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2

样例2：
Input：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0

限制：
1 <= n <= @data
1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
edges[i].length == 3
1 <= edges[i][0] <= 3
1 <= edges[i][1] < edges[i][2] <= n
所有元组 (typei, ui, vi) 互不相同
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,6400 640 64,"class Solution {
public:
int getRoot(vector<int>& par,int x){
        int root = x;
        while(par[root]!=root){
            root = par[root];
        }
        while(par[x]!=root){
            int tmp = par[x];
            par[x] = root;
            x = tmp;
        }
        return root;
    }
    //结合两个节点所在的集合
    bool merge(vector<int>& par,int x,int y){
        int _x = getRoot(par,x);
        int _y = getRoot(par,y);
        if(_x!=_y){
            par[_x]=_y;
            return true;
        }
        return false;
    }
    int solve(int n, vector<vector<int>>& edges) {
        vector<int>par1 = vector<int>(n+1,0);
        vector<int>par2;
        int ans = 0;
        int cnt1 = n,cnt2;
        for(int i =1;i<=n;i++){
            par1[i] = i;
        }
        //先添加第三种类型的边
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==3){
                if(!merge(par1,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt1--;
            }
        }
        par2 = par1;
        cnt2 = cnt1;
        //再添加其余两种类型的边
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==1){
                if(!merge(par1,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt1--;
            }else if(edges[i][0]==2){
                if(!merge(par2,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt2--;
            }
        }
        if(cnt1!=1||cnt2!=1)
            return -1;
        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void graph(int n, int m) {
// Generate an undirected graph with n vertices and m edges. There are no double edges or self-rings in the graph, and must be connected.
    std::vector<std::pair<pair<int,int>, int> > e;
    std::map<std::pair<pair<int,int> ,int>, bool> f;

    std::cout << n << "" "" << m << ""\n"";

    for (int i = 1; i < n; i++)
    {
        for(int j=1;j<=2;j++)
        {
            int p = rng(0, i - 1);
            int val= rng(1,3);
            e.push_back({{p,i},val});
            f[{{p,i},val}] = f[{{i,p},val}] = true;
        }
    }

    // debug(f);
    for (int i = 2*n-1; i <= m; i++) {
        int x, y, z;
        do {
            x = rng(0, n - 1);
            y = rng(0, n - 1);
            z = rng(1,3);
        } while (x == y || f.count({{x,y},z}));

        e.push_back({{x,y},z});
        f[{{x,y},z}] = f[{{y,x},z}] = true;
    }

    std::shuffle(e.begin(), e.end(), rnd);

    for (auto [x, y] : e) {
        cout << y<< "" "" << x.first+1<<' '<<x.second+1 << ""\n"";
    }
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=data;
    int m=4*n;
    graph(n,m);

    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > e;
    for(int i=1;i<=m;i++)
    {
        int x,y,z; cin>>x>>y>>z;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        e.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,e);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,hard,,,,,,,,,,,,,,,,
leetcode20,"There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.
You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.
Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.
Note that node 0 will not be a restricted node.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges, vector<int>& restricted)
}
```

Example 1:
Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4

Example 2:
Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3

Restrictions:
2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.
1 <= restricted.length < n
1 <= restricted[i] < n
All the values of restricted are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","现有一棵由 n 个节点组成的无向树，节点编号从 0 到 n - 1 ，共有 n - 1 条边。
给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。另给你一个整数数组 restricted 表示 受限 节点。
在不访问受限节点的前提下，返回你可以从节点 0 到达的 最多 节点数目。
注意，节点 0 不 会标记为受限节点。

solution内主函数
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges, vector<int>& restricted)
}
```

样例1：
Input：n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4

样例2：
Input：n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3

限制：
2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges 表示一棵有效的树
1 <= restricted.length < n
1 <= restricted[i] < n
restricted 中的所有值 互不相同
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 1000 100000,1000,2560000 12800 128,"class Solution {
    vector<int> p,sz;
    vector<bool> r;
public:
    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    void unionSet(int a, int b) {
        a = find(a), b = find(b);
        if (a != b) {
            if (sz[a] > sz[b]) swap(a, b);
            p[a] = b, sz[b] += sz[a];
        }
    }
    int solve(int n, vector<vector<int>>& edges, vector<int>& restricted) {
        for (int i = 0; i <= n; i ++ ) p.push_back(i),sz.push_back(1),r.push_back(false);
        for (auto &x : restricted) r[x] = true;
        for (auto &e : edges) if (!r[e[1]] && !r[e[0]]) unionSet(e[0], e[1]);
        return sz[find(0)];
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
bool vis[100010];
int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    int n=data;
    int m=rng(1,n/2);
    cout<<n<<' '<<m<<endl;
    for(int i=1;i<n;i++)
        cout<<i<<' '<<rng(0,i-1)<<' ';
    cout<<endl;
    for(int i=1;i<=m;i++)
    {
        int x=rng(1,n-1);
        while(vis[x]) x=rng(1,n-1);
        vis[x]=true; cout<<x<<' ';
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > e;
    vector<int> re;
    for(int i=1;i<n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        e.push_back(temp);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        re.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,e,re);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",graph,middle,,,,,,,,,,,,,,,,
leetcode21,"In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root ""help"" is followed by the word ""ful"", we can form a derivative ""helpful"".
Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.
Return the sentence after the replacement.

solution main function
```cpp
class Solution
{
    public:
    string solve(vector<string>& dictionary, string sentence)
}
```

Example 1:
Input: dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""

Example 2:
Input: dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
Output: ""a a b c""


Restrictions:
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 100
dictionary[i] consists of only lower-case letters.
1 <= sentence.length <= 106
sentence consists of only lower-case letters and spaces.
The number of words in sentence is in the range [1, 1000]
The length of each word in sentence is in the range [1, 1000]
Every two consecutive words in sentence will be separated by exactly one space.
sentence does not have leading or trailing spaces.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","在英语中，我们有一个叫做 词根(root) 的概念，可以词根 后面 添加其他一些词组成另一个较长的单词——我们称这个词为 衍生词 (derivative)。例如，词根 help，跟随着 继承词 ""ful""，可以形成新的单词 ""helpful""。
现在，给定一个由许多 词根 组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有 衍生词 用 词根 替换掉。如果 衍生词 有许多可以形成它的 词根，则用 最短 的 词根 替换它。
你需要输出替换之后的句子。

solution内主函数
```cpp
class Solution
{
    public:
    string solve(vector<string>& dictionary, string sentence)
}
```

样例1：
Input：dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""

样例2：
Input：dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
Output: ""a a b c""

限制：
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 100
dictionary[i] 仅由小写字母组成。
1 <= sentence.length <= 106
sentence 仅由小写字母和空格组成。
sentence 中单词的总量在范围 [1, 1000] 内。
sentence 中每个单词的长度在范围 [1, 1000] 内。
sentence 中单词之间由一个空格隔开。
sentence 没有前导或尾随空格
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    struct Trie {
        unordered_map<char, Trie *> children;
    };
    string solve(vector<string>& dictionary, string sentence) {
        Trie *trie = new Trie();
        for (auto &word : dictionary) {
            Trie *cur = trie;
            for (char &c: word) {
                if (!cur->children.count(c)) {
                    cur->children[c] = new Trie();
                }
                cur = cur->children[c];
            }
            cur->children['#'] = new Trie();
        }
        vector<string> words = split(sentence, ' ');
        for (auto &word : words) {
            word = findRoot(word, trie);
        }
        string ans;
        for (int i = 0; i < words.size() - 1; i++) {
            ans.append(words[i]);
            ans.append("" "");
        }
        ans.append(words.back());
        return ans;
    }

    vector<string> split(string &str, char ch) {
        int pos = 0;
        int start = 0;
        vector<string> ret;
        while (pos < str.size()) {
            while (pos < str.size() && str[pos] == ch) {
                pos++;
            }
            start = pos;
            while (pos < str.size() && str[pos] != ch) {
                pos++;
            }
            if (start < str.size()) {
                ret.emplace_back(str.substr(start, pos - start));
            }
        }
        return ret;
    }

    string findRoot(string &word, Trie *trie) {
        string root;
        Trie *cur = trie;
        for (char &c : word) {
            if (cur->children.count('#')) {
                return root;
            }
            if (!cur->children.count(c)) {
                return word;
            }
            root.push_back(c);
            cur = cur->children[c];
        }
        return root;
    }
};","#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>
#include <algorithm>
using namespace std;
// Function to generate a random word of given length
std::string generateRandomWord(int length) {
    std::string word;
    for (int i = 0; i < length; ++i) {
        word += 'a' + rand() % 26; // Random lowercase letter
    }
    return word;
}

// Function to generate a random dictionary
std::vector<std::string> generateDictionary(int dictSize, int maxWordLength) {
    std::vector<std::string> dictionary;
    for (int i = 0; i < dictSize; ++i) {
        int wordLength = 1 + rand() % maxWordLength; // Random word length between 1 and maxWordLength
        dictionary.push_back(generateRandomWord(wordLength));
    }
    return dictionary;
}

// Function to generate a random sentence
std::string generateSentence(int numWords, int maxWordLength, const std::vector<std::string>& dictionary) {
    std::string sentence;
    for (int i = 0; i < numWords; ++i) {
        int useDictionary = rand() % 2; // 50% chance to use a word from the dictionary
        if (useDictionary && !dictionary.empty()) {
            sentence += dictionary[rand() % dictionary.size()];
        } else {
            int wordLength = 1 + rand() % maxWordLength;
            sentence += generateRandomWord(wordLength);
        }
        if(rand()&1) sentence+=""ing"";
        else if(rand()&1) sentence+=""ed"";
        else if(rand()&1) sentence+=""es"";
        else if(rand()&1) sentence+=""qwerqwe"";
        if (i < numWords - 1) {
            sentence += "" ""; // Add space between words
        }
    }
    return sentence;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    // int data=20;
    srand(static_cast<unsigned>(time(0)));

    // Parameters for data generation
    int dictSize = data;        // Number of words in the dictionary
    int maxWordLength = 50;    // Maximum length of each word
    int numWords = data;        // Number of words in the sentence
    cout<<dictSize<<' '<<numWords<<endl;
    // Generate dictionary and sentence
    std::vector<std::string> dictionary = generateDictionary(dictSize, maxWordLength);
    std::string sentence = generateSentence(numWords, maxWordLength, dictionary);

    // Output the generated data
    for (const auto& word : dictionary) {
        std::cout << word << std::endl;
    }
    std::cout << sentence << std::endl;

    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m;
    cin>>n>>m;
    vector<string> words;
    string text;
    for(int i=1;i<=n;i++)
    {
        string s; cin>>s;
        words.push_back(s);
    }
    for(int i=1;i<=m;i++)
    {
        string s; cin>>s;
        text+=s;
        if(i!=m) text+="" "";
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(words,text);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",string,middle,,,,,,,,,,,,,,,,
leetcode23,"You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
Return the minimum number of extra characters left over if you break up s optimally.


solution main function
```cpp
class Solution {
public:
    int solve(string s, vector<string>& dictionary) {

    }
};
```

Example 1:
Input：s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1

Example 2:
Input：s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3


Restrictions:
1 <= s.length <= @data
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 50
dictionary[i] and s consists of only lowercase English letters
dictionary contains distinct words
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。
请你采取最优策略分割 s ，使剩下的字符 最少 。

solution内主函数
```cpp
class Solution {
public:
    int solve(string s, vector<string>& dictionary) {

    }
};
```

样例1：
Input：s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1

样例2：
Input：s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3

限制：
1 <= s.length <= @data
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 50
dictionary[i] 和 s 只包含小写英文字母。
dictionary 中的单词互不相同。
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    int solve(string s, vector<string>& dictionary) {
        int n = s.size(), m = dictionary.size();
        vector<int> dp(n + 1);
        for (int i = 0; i <= n; i++) dp[i] = i;
        auto func = [&](int p, int q) {
            if (p + dictionary[q].size() > n) return false;
            for (int i = 0; i < dictionary[q].size(); i++) {
                if (s[p + i] != dictionary[q][i]) return false;
            }
            return true;
        };
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < dictionary.size(); j++) {
                if (func(i, j)) {
                    // cout << i << ' ' << j << '\n';
                    dp[i + dictionary[j].size()] = min(dp[i], dp[i + dictionary[j].size()]);
                }
            }
            dp[i + 1] = min(dp[i] + 1, dp[i + 1]); 
        }
        // for (int i = 0; i <= n; i++) cout << dp[i] << ' ';
        // cout << '\n';
        return dp[n];

    }
};","#include <bits/stdc++.h>

using namespace std;

// Helper function to generate a random string of a given length
string generateRandomWord(int mx) {
    string word;
    int len=rand()%9+2;
    for (int i = 1; i <=len; ++i) {
        word += 'a' + rand() % mx;
    }
    return word;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    srand(static_cast<unsigned>(time(0)));
    int n=data;
    int mx=log10(n)+3;
    cout<<n<<endl;
    map<string,bool> mp;
    for(int i=1;i<=n;i++)
    {
        string s=generateRandomWord(mx);
        while(mp.find(s)!=mp.end())
            s=generateRandomWord(mx);
        cout<<s<<endl;
    }
    for(int i=1;i<=n;i++)
        putchar('a'+rand()%mx);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<string> dic;
    string s;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        dic.push_back(s);
    }
    cin>>s;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(s,dic);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",string,middle,,,,,,,,,,,,,,,,
leetcode24,"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Note that the same word in the dictionary may be reused multiple times in the segmentation.

solution main function
```cpp
class Solution {
public:
    bool solve(string s, vector<string>& wordDict) {

    }
};
```

Example 1:
Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true

Example 2:
Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true


Restrictions:
1 <= s.length <= data
1 <= wordDict.length <= data
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

solution内主函数
```cpp
class Solution {
public:
    bool solve(string s, vector<string>& wordDict) {

    }
};
```

样例1：
Input：s = ""leetcode"", wordDict = [""leet"", ""code""]
Output: true

样例2：
Input：s = ""applepenapple"", wordDict = [""apple"", ""pen""]
Output: true

限制：
1 <= s.length <= @data
1 <= wordDict.length <= data
1 <= wordDict[i].length <= 20
s 和 wordDict[i] 仅由小写英文字母组成
wordDict 中的所有字符串 互不相同
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 500 1000,1000,12800 1280 128,"class Solution {
public:
    bool solve(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i < dp.size(); i++) {
            for (auto w : wordDict) {
                int len =  w.size();
                if (i - len >= 0) {
                    if (dp[i - len] && s.substr(i - len, len) == w) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }
        return dp.back();
    }
};","#include <bits/stdc++.h>

using namespace std;

// Helper function to generate a random string of a given length
string generateRandomWord(int mxlen) {
    string word;
    int len=rand()%mxlen+1;
    for (int i = 1; i <=len; ++i) {
        word += 'a' + rand() % 26;
    }
    return word;
}

int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    srand(static_cast<unsigned>(time(0)));
    int n=data;
    cout<<n<<endl;
    vector<string> ch;
    map<string,bool> mp;
    for(int i=1;i<=n;i++)
    {
        string s=generateRandomWord(20);
        while(mp.find(s)!=mp.end()) s=generateRandomWord(20);
        mp.insert({s,true});
        ch.push_back(s);
        cout<<s<<endl;
    }
    string str;
    while(str.size()<n-20)
    {
        int pos=rand()%((int)ch.size());
        str+=ch[pos];
    }
    if(rand()%4==0)
    {
        str.push_back('a');
    }
    cout<<str;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<string> dic;
    string s;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        dic.push_back(s);
    }
    cin>>s;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    int result = solution.solve(s,dic);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",string,middle,,,,,,,,,,,,,,,,
leetcode25,"You are given an array of strings products and a string searchWord.
Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.

solution main function
```cpp
class Solution {
public:
    vector<vector<string>> solve(vector<string>& products, string searchWord){

    }
};
```

Example 1:
Input: products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse""
Output: [[""mobile"",""moneypot"",""monitor""],[""mobile"",""moneypot"",""monitor""],[""mouse"",""mousepad""],[""mouse"",""mousepad""],[""mouse"",""mousepad""]]

Example 2:
Input: products = [""havana""], searchWord = ""havana""
Output: [[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]]

Restrictions:
1 <= products.length <= @data
1 <= products[i].length <= 3000
1 <= sum(products[i].length) <= 2 * 10^4
All the strings of products are unique.
products[i] consists of lowercase English letters.
1 <= searchWord.length <= @data
searchWord consists of lowercase English letters.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。
请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。
请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。

solution内主函数
```cpp
class Solution {
public:
    vector<vector<string>> solve(vector<string>& products, string searchWord){

    }
};
```

样例1：
Input: products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse""
Output: [[""mobile"",""moneypot"",""monitor""],[""mobile"",""moneypot"",""monitor""],[""mouse"",""mousepad""],[""mouse"",""mousepad""],[""mouse"",""mousepad""]]

样例2：
Input：products = [""havana""], searchWord = ""havana""
Output: [[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]]

限制：

1 <= products.length <= @data
1 <= Σ products[i].length <= 2 * 10^4
products[i] 中所有的字符都是小写英文字母。
1 <= searchWord.length <= @data
searchWord 中所有字符都是小写英文字母。
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 500 1000,1000,12800 1280 128,"class Solution {
public:
    vector<vector<string>> solve(vector<string>& products, string searchWord) {
        sort(products.begin(), products.end());
        string query;
        auto iter_last = products.begin();
        vector<vector<string>> ans;
        for (char ch : searchWord) {
            query += ch;
            auto iter_find = lower_bound(iter_last, products.end(), query);
            vector<string> selects;
            for (int i = 0; i < 3; ++i) {
                if (iter_find + i < products.end() && (*(iter_find + i)).find(query) == 0) {
                    selects.push_back(*(iter_find + i));
                }
            }
            ans.push_back(move(selects));
            iter_last = iter_find;
        }
        return ans;
    }
};","#include <bits/stdc++.h>

using namespace std;

// Helper function to generate a random string of a given length
string generateRandomWord(int mxlen) {
    string word;
    int len=rand()%mxlen+1;
    for (int i = 1; i <=len; ++i) {
        word += 'a' + rand() % 26;
    }
    return word;
}
string bas;
string pre()
{
    string s;
    int len=rand()%20;
    for(int j=0;j<len;j++)
        s.push_back(bas[j]);
    len=rand()%20;
    for(int j=0;j<len;j++)
        s.push_back('a' + rand() % 26);
    return s;
}
int main(int argc, char* argv[]) {
    int data = std::atoi(argv[1]);
    srand(static_cast<unsigned>(time(0)));
    int n=data;
    cout<<n<<endl;
    for (int i = 1; i <=40; ++i)
        bas += 'a' + rand() % 26;
    map<string,bool> mp;
    for(int i=1;i<=n;i++)
    {
        string s;
        s=pre();
        while(mp.find(s)!=mp.end())
            s=pre();
        mp.insert({s,true});
        cout<<s<<endl;
    }
    cout<<bas;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<string> dic;
    string bas;
    for(int i=1;i<=n;i++)
    {
        cin>>bas;
        dic.push_back(bas);
    }
    cin>>bas;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(dic,bas);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result)
    {
        for(auto str:it)
            cout<<str<<' ';
        cout<<endl;
    }
    return 0;
}",string,middle,,,,,,,,,,,,,,,,
leetcode26,"There are n soldiers standing in a line. Each soldier is assigned a unique rating value.
You have to form a team of 3 soldiers amongst them under the following rules:
    Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
    A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& rating) {

    }
};
```

Example 1:
Input: rating = [2,5,3,4,1]
Output: 3

Example 2:
Input：rating = [2,1,3]
Output: 0

Restrictions:
n == rating.length
3 <= n <= @data
1 <= rating[i] <= 10^5
All the integers in rating are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。
从中选出 3 个士兵组成一个作战单位，规则如下：
    从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]
    作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n
请你返回按上述条件组建的作战单位的方案数。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<int>& rating) {

    }
};
```

样例1：
Input: rating = [2,5,3,4,1]
Output: 3

样例2：
Input：rating = [2,1,3]
Output: 0

限制：
n == rating.length
3 <= n <= @data
1 <= rating[i] <= 10^5
rating 中的元素都是唯一的
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    int solve(vector<int>& rating) {
        int n = rating.size();
        int ans = 0;
        for (int j = 1; j < n - 1; ++j) {
            int iless = 0, imore = 0;
            int kless = 0, kmore = 0;
            for (int i = 0; i < j; ++i) {
                if (rating[i] < rating[j]) {
                    ++iless;
                }
                else if (rating[i] > rating[j]) {
                    ++imore;
                }
            }
            for (int k = j + 1; k < n; ++k) {
                if (rating[k] < rating[j]) {
                    ++kless;
                }
                else if (rating[k] > rating[j]) {
                    ++kmore;
                }
            }
            ans += iless * kmore + imore * kless;
        }
        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

void Array(int n, int lim) { // Generates an array with n elements
    int m = lim;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = rng(1, m);
        std::cout << a[i] << "" \n""[i == n - 1];
    }
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    cout<<n<<endl;
    Array(n,100000);
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n;
    cin>>n;
    vector<int> rat;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        rat.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(rat);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",segment_tree,middle,"class Solution {
public:
    static constexpr int MAX_N = 200 + 5;

    int c[MAX_N];
    vector <int> disc;
    vector <int> iLess, iMore, kLess, kMore;

    int lowbit(int x) {
        return x & (-x);
    }

    void add(int p, int v) {
        while (p < MAX_N) {
            c[p] += v;
            p += lowbit(p);
        }
    }

    int get(int p) {
        int r = 0;
        while (p > 0) {
            r += c[p];
            p -= lowbit(p);
        }
        return r;
    }

    int solve(vector<int>& rating) {
        disc = rating;
        disc.push_back(-1);
        sort(disc.begin(), disc.end());
        auto getId = [&] (int target) {
            return lower_bound(disc.begin(), disc.end(), target) - disc.begin();
        };


        iLess.resize(rating.size());
        iMore.resize(rating.size());
        kLess.resize(rating.size());
        kMore.resize(rating.size());

        for (int i = 0; i < rating.size(); ++i) {
            auto id = getId(rating[i]);
            iLess[i] = get(id);
            iMore[i] = get(201) - get(id); 
            add(id, 1);
        }

        memset(c, 0, sizeof c);
        for (int i = rating.size() - 1; i >= 0; --i) {
            auto id = getId(rating[i]);
            kLess[i] = get(id);
            kMore[i] = get(201) - get(id); 
            add(id, 1);
        }

        int ans = 0;
        for (unsigned i = 0; i < rating.size(); ++i) {
            ans += iLess[i] * kMore[i] + iMore[i] * kLess[i];
        }

        return ans;
    }
};",,,,,,,,,,,,,,,
leetcode27,"Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {

    }
};
```

Example 1:
Input: s = ""abc""
Output: 3

Example 2:
Input: s = ""aaa""
Output: 6

Restrictions:
1 <= s.length <= @data
s consists of lowercase English letters.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。

solution内主函数
```cpp
class Solution {
public:
    int solve(string s) {

    }
};
```

样例1：
Input: s = ""abc""
Output: 3

样例2：
Input：s = ""aaa""
Output: 6

限制：
1 <= s.length <= @data
s 由小写英文字母组成
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    int solve(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s[l] == s[r]) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};","#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

// Function to generate a random string of given length
string generateRandomString(int length,int siz) {
    static const string charset = ""abcdefghijklmnopqrstuvwxyz"";
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dist(0, siz);

    string result;
    for (int i = 0; i < length; ++i) {
        result += charset[dist(gen)];
    }
    return result;
}

// Function to generate a string with many palindromic substrings
string generatePalindromeRichString(int length,int siz) {
    string half = generateRandomString(length / 2,siz);
    string palindrome = half + string(half.rbegin(), half.rend());
    if (length % 2 != 0) {
        palindrome.insert(palindrome.begin() + length / 2, 'a');
    }
    return palindrome;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    string str;
    while(str.size()<n)
    {
        int len=rnd()%30+1;
        str+=generatePalindromeRichString(len,rnd()%20);
    }
    while(str.size()>n) str.pop_back();
    cout<<str;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    string str; cin>>str;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(str);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",string,middle,"class Solution {
public:
    int solve(string s) {
        int n = s.size();
        string t = ""$#"";
        for (const char &c: s) {
            t += c;
            t += '#';
        }
        n = t.size();
        t += '!';

        auto f = vector <int> (n);
        int iMax = 0, rMax = 0, ans = 0;
        for (int i = 1; i < n; ++i) {
            f[i] = (i <= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;
            while (t[i + f[i]] == t[i - f[i]]) ++f[i];
            if (i + f[i] - 1 > rMax) {
                iMax = i;
                rMax = i + f[i] - 1;
            }
            ans += (f[i] / 2);
        }

        return ans;
    }
};",,,,,,,,,,,,,,,
leetcode28,"You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.
For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].
Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& arr, int k) {

    }
};
```

Example 1:
Input: arr = [1,2,3,5], k = 3
Output: [2,5]

Example 2:
Input: arr = [1,7], k = 1
Output: [1,7]

Restrictions:
2 <= arr.length <= @data
1 <= arr[i] <= 2*10^6
arr[0] == 1
arr[i] is a prime number for i > 0.
All the numbers of arr are unique and sorted in strictly increasing order.
1 <= k <= arr.length * (arr.length - 1) / 2
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 质数 组成，且其中所有整数互不相同。
对于每对满足 0 <= i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。
那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。

solution内主函数
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& arr, int k) {

    }
};
```

样例1：
Input: arr = [1,2,3,5], k = 3
Output: [2,5]

样例2：
Input：arr = [1,7], k = 1
Output: [1,7]

限制：

2 <= arr.length <= @data
1 <= arr[i] <= 2*10^6
arr[0] == 1
arr[i] 是一个 质数 ，i > 0
arr 中的所有数字 互不相同 ，且按 严格递增 排序
1 <= k <= arr.length * (arr.length - 1) / 2

时间限制：@time_limit ms
内存限制：@memory_limit KB",10 1000 50000,1000,12800 1280 128,"class Solution {
public:
    vector<int> solve(vector<int>& arr, int k) {
        int n = arr.size();
        double left = 0.0, right = 1.0;
        while (true) {
            double mid = (left + right) / 2;
            int i = -1, count = 0;
            int x = 0, y = 1;
            for (int j = 1; j < n; ++j) {
                while ((double)arr[i + 1] / arr[j] < mid) {
                    ++i;
                    if (arr[i] * y > arr[j] * x) {
                        x = arr[i];
                        y = arr[j];
                    }
                }
                count += i + 1;
            }
            if (count == k) {
                return {x, y};
            }
            if (count < k) {
                left = mid;
            }
            else {
                right = mid;
            }
        }
    }
};","#include <algorithm>
#include<bits/stdc++.h>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
const int N=1e7+10;
int cnt,pri[N];
bool vis[N];

void Prime()
{
	int temp=2e6;
	for(int i=2;i<=temp;i++)
	{
		if(!vis[i])	pri[++cnt]=i;
		for(int j=1;j<=cnt&&pri[j]*i<=temp;j++)
		{
			vis[i*pri[j]]=true;
			if(i%pri[j]==0)	break;
		}
	}
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    long long n=data; Prime();
    long long k=min(1000000000ll,n*(n-1)/2);
    k=rng(k/2,k);
    cout<<n<<' '<<k<<endl;
    random_shuffle(pri+1,pri+cnt+1);
    sort(pri+1,pri+n+1);
    for(int i=1;i<=n;i++) cout<<pri[i]<<' ';
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,k;cin>>n>>k;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(num,k);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result) cout<<it;
    return 0;
}",double pointer,hard,,,,,,,,,,,,,,,,
leetcode29,"You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.
The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).
Find the kth largest value (1-indexed) of all the coordinates of matrix.

solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& matrix, int k) {

    }
};
```

Example 1:
Input: matrix = [[5,2],[1,6]], k = 1
Output: 7

Example 2:
Input：matrix = [[5,2],[1,6]], k = 2
Output: 5

Restrictions:
m == matrix.length
n == matrix[i].length
1 <= m, n <= @data
0 <= matrix[i][j] <= 10^6
1 <= k <= m * n
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m * n 由非负整数组成。
矩阵中坐标 (a, b) 的 目标值 可以通过对所有元素 matrix[i][j] 执行异或运算得到，其中 i 和 j 满足 0 <= i <= a < m 且 0 <= j <= b < n（下标从 0 开始计数）。
请你找出 matrix 的所有坐标中第 k 大的目标值（k 的值从 1 开始计数）。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& matrix, int k) {

    }
};
```
样例1：
Input: matrix = [[5,2],[1,6]], k = 1
Output: 7

样例2：
Input：matrix = [[5,2],[1,6]], k = 2
Output: 5

限制：
m == matrix.length
n == matrix[i].length
1 <= m, n <= @data
0 <= matrix[i][j] <= 10^6
1 <= k <= m * n
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    int solve(vector<vector<int>>& matrix, int k) {
        int m = matrix.size(), n = matrix[0].size();
        // vector<vector<int>> pre(m + 1, vector<int>(n + 1));
        vector<int> results;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if(i-1>=0) matrix[i][j] ^= matrix[i - 1][j];
                if(j-1>=0) matrix[i][j] ^= matrix[i][j - 1];
                if(i-1>=0&&j-1>=0) matrix[i][j] ^= matrix[i - 1][j - 1];
                results.push_back(matrix[i][j]);
            }
        }
        nth_element(results.begin(), results.begin() + k - 1, results.end(), greater<int>());
        return results[k - 1];
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data,m=data;
    int k=rng(1,n*m);
    cout<<n<<' '<<m<<' '<<k<<endl;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cout<<rng(1,1e6)<<' ';
        cout<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m,k;cin>>n>>m>>k;
    vector<vector<int> > num;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        num.push_back(temp);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(num,k);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",bit operation,middle,"class Solution {
public:
    int solve(vector<vector<int>>& matrix, int k) {
        int n = matrix.size(), m = matrix[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                matrix[i][j] ^=
                    (i - 1 > -1 ? matrix[i - 1][j] : 0) ^
                    (j - 1 > -1 ? matrix[i][j - 1] : 0) ^
                    (i - 1 > -1 && j - 1 > -1 ? matrix[i - 1][j - 1] : 0);
                if (pq.size() < k)
                    pq.push(matrix[i][j]);
                else {
                    if (pq.top() < matrix[i][j]) {
                        pq.pop();
                        pq.push(matrix[i][j]);
                    }
                }
            }
        }
        return pq.top();
    }
};",,,,,,,,,,,,,,,
leetcode30,"The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.
    For example, ""ACGAATTCCG"" is a DNA sequence.
When studying DNA, it is useful to identify repeated sequences within the DNA.
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.

solution main function
```cpp
class Solution {
public:
    vector<string> solve(string s) {

    }
};
```

Example 1:
Input: s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""
Output: [""AAAAACCCCC"",""CCCCCAAAAA""]

Example 2:
Input: s = ""AAAAAAAAAAAAA""
Output: [""AAAAAAAAAA""]

Restrictions:
1 <= s.length <= @data
s[i] is either 'A', 'C', 'G', or 'T'.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。
    例如，""ACGAATTCCG"" 是一个 DNA序列 。
在研究 DNA 时，识别 DNA 中的重复序列非常有用。
给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。

solution内主函数
```cpp
class Solution {
public:
    vector<string> solve(string s) {

    }
};
```
样例1：
Input: s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""
Output: [""AAAAACCCCC"",""CCCCCAAAAA""]

样例2：
Input：s = ""AAAAAAAAAAAAA""
Output: [""AAAAAAAAAA""]

限制：
0 <= s.length <= @data
s[i]=='A'、'C'、'G' or 'T'
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 100000,1000,12800 1280 128,"class Solution {
    const int L = 10;
    unordered_map<char, int> bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};
public:
    vector<string> solve(string s) {
        vector<string> ans;
        int n = s.length();
        if (n <= L) {
            return ans;
        }
        int x = 0;
        for (int i = 0; i < L - 1; ++i) {
            x = (x << 2) | bin[s[i]];
        }
        unordered_map<int, int> cnt;
        for (int i = 0; i <= n - L; ++i) {
            x = ((x << 2) | bin[s[i + L - 1]]) & ((1 << (L * 2)) - 1);
            if (++cnt[x] == 2) {
                ans.push_back(s.substr(i, L));
            }
        }
        return ans;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int ch[5]={'A','C','G','T'};
string get()
{
    string str;
    for(int i=1;i<=10;)
    {
        int lim=11-i;
        int num=rng(1,lim);
        // cout<<i<<' '<<num<<endl;
        char c=ch[rnd()%4];
        for(int j=1;j<=num;j++)
            str.push_back(c);
        i+=num;
    }
    // cout<<""Test""<<str<<endl;
    return str;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    int m=rng(3,n/20);
    // cout<<m<<endl;
    vector<string> s;
    for(int i=1;i<=m;i++)
    {
        string str=get();
        s.push_back(str);
        s.push_back(str);
    }
    for(int i=20*m;i<=n;i++)
    {
        string str=get();
        str.push_back(ch[rnd()%4]);
        s.push_back(str);
    }
    random_shuffle(s.begin(),s.end());
    for(auto it:s) cout<<it;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    string str; cin>>str;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(str);
    get_usage(argv[0], argv[1]);

    // output
    for(auto it:result) cout<<it;
    return 0;
}",bit operation,middle,,,,,,,,,,,,,,,,
leetcode31,"Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:
    perm[i] is divisible by i.
    i is divisible by perm[i].
Given an integer n, return the number of the beautiful arrangements that you can construct.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 2

Example 2:
Input: n = 1
Output: 1

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：
    perm[i] 能够被 i 整除
    i 能够被 perm[i] 整除
给你一个整数 n ，返回可以构造的 优美排列 的 数量 。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 2
Output: 2

样例2：
Input：n = 1
Output: 1

限制：
1<=n<=@data>
时间限制：@time_limit ms
内存限制：@memory_limit KB",5 10 15,1000,12800 1280 128,"class Solution {
    bool check[16]={};
    int ans=0;
public:
    int solve(int n)
    {
        dfs(1,n);
        return ans;
    }
    void dfs(int pos,int n)
    {
        if(pos==n+1)
        {
            ans++;
            return;
        }
        for(int i=1;i<=n;i++)
        {
            if(!check[i]&&(pos%i==0||i%pos==0))
            {
                check[i]=true;
                dfs(pos+1,n);
                check[i]=false;
            }
        }

    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data-5,data);
    cout<<n<<endl;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",dp,hard,"class Solution {
public:
    int solve(int n) {
        vector<int> f(1<<n,0);
        f[0]=1;
        for(int mask=1;mask<(1<<n);mask++){
            int num=__builtin_popcount(mask);
            for(int i=0;i<n;i++){
                if(((mask)&(1<<i))&&((i+1)%num==0||num%(i+1)==0)){
                    f[mask]+=f[mask^(1<<i)];
                }
            }
        }
        return f.back();
    }
};",,,,,,,,,,,,,,,
leetcode32,"Given an array of integers arr.
We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).
Let's define a and b as follows:
    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.
Return the number of triplets (i, j and k) Where a == b.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& arr) {

    }
};
```

Example 1:
Input: arr = [2,3,1,6,7]
Output: 4

Example 2:
Input: arr = [2,3,1,6,7]
Output: 4

Restrictions:
1 <= arr.length <= @data
1 <= arr[i] <= 10^8
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数数组 arr 。
现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。
a 和 b 定义如下：
    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。
请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<int>& arr) {

    }
};
```

样例1：
Input: arr = [2,3,1,6,7]
Output: 4

样例2：
Input：arr = [1,1,1,1,1]
Output: 10

限制：
1 <= arr.length <= @data
1 <= arr[i] <= 10^8
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    int solve(vector<int> &arr) {
        int n = arr.size();
        unordered_map<int, int> cnt, total;
        int ans = 0, s = 0;
        for (int k = 0; k < n; ++k) {
            int val = arr[k];
            if (cnt.count(s ^ val)) {
                ans += cnt[s ^ val] * k - total[s ^ val];
            }
            ++cnt[s];
            total[s] += k;
            s ^= val;
        }
        return ans;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data; cout<<n<<endl;
    int num=rng(0,log2(1e8/32));
    for(int i=1;i<=n;i++)
        cout<<(rng(1,32)<<num)<<' ';
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    vector<int> arr;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        arr.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(arr);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",bit operation,middle,"class Solution {
public:
    int solve(vector<int>& arr) {
        int ans = 0;
        int n = arr.size();
        for (int i = 0; i < n - 1; ++i) {
            int temp = arr[i];
            for (int j = i + 1; j < n; ++j) {
                temp ^= arr[j];
                if (temp == 0)
                    ans += j - i;
            }
        }
        return ans;
    }
};",,,,,,,,,,,,,,,
leetcode33,"Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.

solution main function
```cpp
class Solution {
public:
    bool solve(string s, int k) {

    }
};
```

Example 1:
Input: s = ""00110110"", k = 2
Output: true

Example 2:
Input: s = ""0110"", k = 1
Output: true

Restrictions:
1 <= s.length <= @data
s[i] is either '0' or '1'.
1 <= k <= 20
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 true ，否则请返回 false 。

solution内主函数
```cpp
class Solution {
public:
    bool solve(string s, int k) {

    }
};
```

样例1：
Input: arr = [2,3,1,6,7]
Output: 4

样例2：
Input：arr = [1,1,1,1,1]
Output: 10

限制：
1 <= s.length <= @data
s[i] 不是'0' 就是 '1'
1 <= k <= 20
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 100000,1000,12800 1280 128,"class Solution {
public:
    bool solve(string s, int k) {
        int n = s.size();
        if(k > n) {
            return false;
        }
        int cur = 0;
        vector<bool> vis(1 << k, false);
        for(int i = 0; i < k; ++i) {
            cur = (cur << 1) + (s[i] == '1');    
        }
        vis[cur] = true;
        for(int i = k; i < n; ++i) {
            cur = (cur << 1) + (s[i] == '1');
            cur &= ~(1 << k);
            vis[cur] = true;
        }
        for(bool v : vis) {
            if(!v) {
                return false;
            }
        }
        return true;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data,k=rng(1,20);
    for(int i=1;i<=n;i++) cout<<rng(0,1);
    cout<<endl<<k;
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; string str; cin>>n>>str;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    int result = solution.solve(str,n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",bit operation,middle,,,,,,,,,,,,,,,,
leetcode34,"Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums = [3,10,5,25,2,8]
Output: 28

Example 2:
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127

Restrictions:
1 <= nums.length <= @data
0 <= nums[i] <= 2^31 - 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {

    }
};
```

样例1：
Input: nums = [3,10,5,25,2,8]
Output: 28

样例2：
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127

限制：
1 <= nums.length <= @data
0 <= nums[i] <= 2^31 - 1
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 100000,1000,12800 1280 128,"class Solution {
public:
    int solve(vector<int>& nums) {
        int n=nums.size(),maxv=*max_element(nums.begin(),nums.end());
        if(maxv==0)
        return 0;
        int high=31-__builtin_clz(maxv);
        int ans=0,mask=0;
        unordered_set<int>seen;
        for(int i=high;i>=0;i--){
            seen.clear();
            mask|=1<<i;
            int tmp=ans|(1<<i);
            for(int x:nums){
                x&=mask;
                if(seen.find(tmp^x)!=seen.end()){
                    ans=tmp;
                    break;
                }
                seen.insert(x);
            }
        }
        return ans;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data; cout<<n<<endl;
    for(int i=1;i<=n;i++)
        cout<<rng(1,1e8)<<' ';
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    int result = solution.solve(num);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",STL,middle,,,,,,,,,,,,,,,,
leetcode35,"You are given a binary array nums and an integer k.
A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.
A subarray is a contiguous part of an array.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {

    }
};
```

Example 1:
Input: nums = [0,1,0], k = 1
Output: 2

Example 2:
Input: nums = [1,1,0], k = 2
Output: -1

Restrictions:
1 <= nums.length <= @data
1 <= k <= nums.length
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给定一个二进制数组 nums 和一个整数 k 。
k位翻转 就是从 nums 中选择一个长度为 k 的 子数组 ，同时把子数组中的每一个 0 都改成 1 ，把子数组中的每一个 1 都改成 0 。
返回数组中不存在 0 所需的最小 k位翻转 次数。如果不可能，则返回 -1 。
子数组 是数组的 连续 部分。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {

    }
};
```

样例1：
Input: nums = [3,10,5,25,2,8]
Output: 28

样例2：
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127

限制：
1 <= nums.length <= @data
1 <= k <= nums.length
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 100000,1000,12800 1280 128,"class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int ans = 0;
        int n = nums.size();
        int cnt = 0;
        for(int i=0;i<n;i++) {
            if(i>=k&&nums[i-k]>1) {
                cnt^=1;
                nums[i-k]-=2;
            }
            if(nums[i]==cnt) {
                if(i+k>n) return -1;
                cnt^=1;
                nums[i]+=2;
                ans++;
            }
        }
        return ans;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
bool s[100010];
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    int k=rng(10,n/3);
    cout<<n<<' '<<k;
    int m=rng(n/2,n);
    for(int i=1;i<=m;i++)
    {
        int l=rng(1,n-k+1);
        int r=l+k-1;
        s[l]^=1; s[r+1]^=1;
    }
    int pre=0;
    for(int i=1;i<=n;i++)
    {
        pre^=s[i];
        cout<<pre<<' ';
    }
    return 0;
}","#include <bits/stdc++.h>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,k; cin>>n>>k;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    int result = solution.solve(num,k);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",bit operation,hard,,,,,,,,,,,,,,,,
leetcode36,"Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.

solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

Example 2:
Input: nums = [4,4,3,2,1]
Output: [[4,4]]

Restrictions:
1 <= nums.length <= @data
-100 <= nums[i] <= 100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

solution内主函数
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums) {

    }
};
```

样例1：
Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

样例2：
Input: nums = [4,4,3,2,1]
Output: [[4,4]]

限制：
1 <= nums.length <= @data
-100 <= nums[i] <= 100
时间限制：@time_limit ms
内存限制：@memory_limit KB",5 10 15,1000,12800 1280 128,"class Solution {
public:
    vector<int> temp; 
    vector<vector<int>> ans;

    void dfs(int cur, int last, vector<int>& nums) {
        if (cur == nums.size()) {
            if (temp.size() >= 2) {
                ans.push_back(temp);
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.push_back(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.pop_back();
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }

    vector<vector<int>> solve(vector<int>& nums) {
        dfs(0, INT_MIN, nums);
        return ans;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
bool s[100010];
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    cout<<n<<endl;
    for(int i=1;i<=n;i++)
        cout<<rng(-7,7)<<' ';
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(num);
    get_usage(argv[0], argv[1]);

    // output
    sort(result.begin(),result.end());
    for(auto it:result)
    {
        for(auto t:it)
            cout<<t<<' ';
        cout<<endl;
    }
    return 0;
}",bit operation,middle,,,,,,,,,,,,,,,,
leetcode37,"Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.

solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3

Example 2:
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5

Restrictions:
1 <= nums1.length, nums2.length <= @data
0 <= nums1[i], nums2[i] <= 100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。

solution内主函数
```cpp
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {

    }
};
```

样例1：
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3

样例2：
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5

限制：
1 <= nums1.length, nums2.length <= @data
0 <= nums1[i], nums2[i] <= 100
时间限制：@time_limit ms
内存限制：@memory_limit KB",10 100 1000,1000,12800 1280 128,"class Solution {
public:
    const int mod = 1000000009;
    const int base = 113;

    long long qPow(long long x, long long n) {
        long long ret = 1;
        while (n) {
            if (n & 1) {
                ret = ret * x % mod;
            }
            x = x * x % mod;
            n >>= 1;
        }
        return ret;
    }

    bool check(vector<int>& A, vector<int>& B, int len) {
        long long hashA = 0;
        for (int i = 0; i < len; i++) {
            hashA = (hashA * base + A[i]) % mod;
        }
        unordered_set<long long> bucketA;
        bucketA.insert(hashA);
        long long mult = qPow(base, len - 1);
        for (int i = len; i < A.size(); i++) {
            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;
            bucketA.insert(hashA);
        }
        long long hashB = 0;
        for (int i = 0; i < len; i++) {
            hashB = (hashB * base + B[i]) % mod;
        }
        if (bucketA.count(hashB)) {
            return true;
        }
        for (int i = len; i < B.size(); i++) {
            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;
            if (bucketA.count(hashB)) {
                return true;
            }
        }
        return false;
    }

    int solve(vector<int>& A, vector<int>& B) {
        int left = 1, right = min(A.size(), B.size()) + 1;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (check(A, B, mid)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left - 1;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}
int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=data;
    cout<<n<<' '<<n<<endl;
    int len=rng(n/3,n/2);
    vector<int> num;
    for(int i=1;i<=len;i++)
        num.push_back(rng(0,100));
    for(int i=1;i<=2;i++)
    {
        int pos=rng(1,n-len+1);
        for(int j=1;j<pos;j++)
            cout<<rng(0,100)<<' ';
        for(auto it:num) cout<<it<<' ';
        for(int j=pos+len;j<=n;j++)
            cout<<rng(0,100)<<' ';
        cout<<endl;
    }
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m; cin>>n>>m;
    vector<int> num1,num2;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num1.push_back(x);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        num2.push_back(x);
    }
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(num1,num2);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",dp,middle,"class Solution {
public:
    int maxLength(vector<int>& A, vector<int>& B, int addA, int addB, int len) {
        int ret = 0, k = 0;
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i]) {
                k++;
            } else {
                k = 0;
            }
            ret = max(ret, k);
        }
        return ret;
    }
    int solve(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int len = min(m, n - i);
            int maxlen = maxLength(A, B, i, 0, len);
            ret = max(ret, maxlen);
        }
        for (int i = 0; i < m; i++) {
            int len = min(n, m - i);
            int maxlen = maxLength(A, B, 0, i, len);
            ret = max(ret, maxlen);
        }
        return ret;
    }
};",,,,,,,,,,,,,,,
leetcode38,"Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted，The answer is modulo 998224353.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 5

Example 2:
Input: n = 2
Output: 15

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量，答案对 998224353 取模。

字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 1
Output: 5

样例2：
Input: n = 2
Output: 15

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    const long long mod=998244353;
    const long long inv_24=291154603;
    int solve(long long n) {
        return (n + 1ll) * (n + 2ll)%mod * (n + 3ll)%mod * (n + 4ll)%mod * inv_24%mod;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode39,"You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.
You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.
In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.
Return the minimum number of moves that you need to determine with certainty what the value of f is.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 2

Example 2:
Input: n = 100
Output: 14

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你 2 枚相同 的鸡蛋，和一栋从第 1 层到第 n 层共有 n 层楼的建筑。
已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都 会碎 ，从 f 楼层或比它低 的楼层落下的鸡蛋都 不会碎 。
每次操作，你可以取一枚 没有碎 的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 2
Output: 2

样例2：
Input: n = 100
Output: 14

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    int solve(int n) {
        int tmp = sqrt(2*n);
        if(tmp * (tmp + 1) >= 2 * n){return tmp;}
        return tmp + 1;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode40,"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
The rules of the game are as follows:
    Start at the 1st friend.
    Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
    The last friend you counted leaves the circle and loses the game.
    If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
    Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int k) {

    }
};
```

Example 1:
Input: n = 5, k = 2
Output: 3

Example 2:
Input: n = 6, k = 5
Output: 1

Restrictions:
1 <= k <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。
游戏遵循如下规则：
    从第 1 名小伙伴所在位置 开始 。
    沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
    你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
    如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
    否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n, int k) {

    }
};
```

样例1：
Input: n = 5, k = 2
Output: 3

样例2：
Input: n = 6, k = 5
Output: 1

限制：
1 <= k <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    int solve(int n, int k) {
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans = (ans + k) % i;
        }
        return ans + 1;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    int k=rng(2,n);
    cout<<n<<' '<<k;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,k; cin>>n>>k;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,k);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode41,"You are given an even integer n​​​​​​. You initially have a permutation perm of size n​​ where perm[i] == i​ (0-indexed)​​​​.
In one operation, you will create a new array arr, and for each i:
    If i % 2 == 0, then arr[i] = perm[i / 2].
    If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
You will then assign arr​​​​ to perm.
Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 1

Example 2:
Input: n = 4
Output: 2

Restrictions:
2 <= n <= @data
n​​​​​​ is even.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。
一步操作中，你将创建一个新数组 arr ，对于每个 i ：
    如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]
    如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]
然后将 arr​​ 赋值​​给 perm 。
要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 2
Output: 1

样例2：
Input: n = 4
Output: 2

限制：
2 <= n <= @data
n​​​​​​ 是一个偶数
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    int solve(int n) {
        int halfLen = n >> 1;
        int ret = 0;
        int num1Id = 1;
        do{
            if(num1Id < halfLen)
                num1Id <<= 1;
            else    
                num1Id = (num1Id << 1) - n + 1;
            ++ret;
        }while(num1Id != 1);
        return ret;        
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/4,data/2);
    cout<<2*n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode42,"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.
The answer is modulus 998244353.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 3
Output: 5

Example 2:
Input: n = 1
Output: 1

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
答案对998244353取模。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 3
Output: 5

样例2：
Input: n = 1
Output: 1

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    const long long mod=998244353;
    int solve(int n) {
        long long C = 1;
        vector<long long> inv(n+3);
        inv[0]=inv[1]=1;
        for(int i=2;i<=n+1;i++)
            inv[i]=((mod-mod/i)*inv[mod%i])%mod;
        for (int i = 0; i < n; ++i) {
            C = C * 2ll%mod * (2ll * i + 1ll)%mod * inv[i+2]%mod;
        }
        return (int)C;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,"class Solution {
public:
    const long long mod=998244353;
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve(int n) {
        long long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2ll%mod * (2ll * i + 1ll)%mod * power(i+2,mod-2)%mod;
        }
        return (int)C;
    }
};",,,,,,,,,,,,,,,
leetcode43,"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The answer is modulus 998244353.

solution main function
```cpp
class Solution {
public:
    int solve(int m,int n) {

    }
};
```

Example 1:
Input: m = 3, n = 7
Output: 28

Example 2:
Input: m = 3, n = 2
Output: 3

Restrictions:
1 <= m, n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","一个机器人位于一个 m x n 网格的左上角 
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
问总共有多少条不同的路径？
答案对 998244353 取模

solution内主函数
```cpp
class Solution {
public:
    int solve(int m,int n) {

    }
};
```

样例1：
Input: m = 3, n = 7
Output: 28

样例2：
Input: m = 3, n = 2
Output: 3

限制：
1 <= m, n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    const long long mod=998244353;
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve(int m,int n) {
        long long ans = 1,tx=1,ty=1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            tx=tx*x%mod; ty=ty*y%mod;
        }
        return tx*power(ty,mod-2)%mod;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    int m=rng(data/2,data);
    cout<<n<<' '<<m;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n,m; cin>>n>>m;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n,m);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,hard,,,,,,,,,,,,,,,,
leetcode44,"Given an integer n, return the least number of perfect square numbers that sum to n.
A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 12
Output: 3

Example 2:
Input: n = 13
Output: 2

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 12
Output: 3

样例2：
Input: n = 13
Output: 2

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    bool isPerfectSquare(int x) {
        int y = sqrt(x);
        return y * y == x;
    }

    bool checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }

    int solve(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,hard,,,,,,,,,,,,,,,,
leetcode45,"There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:
    At the first minute, color any arbitrary unit cell blue.
    Every minute thereafter, color blue every uncolored cell that touches a blue cell
Return the number of colored cells at the end of n minutes.

solution main function
```cpp
class Solution {
public:
    long long solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 1

Example 2:
Input: n = 2
Output: 5

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数 n ，表示你需要执行以下步骤 n 分钟：
    第一分钟，将 任一 格子染成蓝色。
    之后的每一分钟，将与蓝色格子相邻的 所有 未染色格子染成蓝色。
请你返回 n 分钟之后 被染色的格子 数目。

solution内主函数
```cpp
class Solution {
public:
    long long solve(int n) {

    }
};
```

样例1：
Input: n = 1
Output: 1

样例2：
Input: n = 2
Output: 5

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    long long solve(int n) {
        return static_cast<long long>(n) * n + static_cast<long long>(n - 1) * (n - 1);
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode46,"Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.
Return the maximum product you can get.
The answer is modulus 998244353

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 1

Example 2:
Input: n = 2
Output: 5

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。 答案对 998244353取模。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 1
Output: 1

样例2：
Input: n = 2
Output: 5

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",50 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    const long long mod=998244353;
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int quotient = n / 3;
        int remainder = n % 3;
        if (remainder == 0)
            return power(3, quotient);
        else if (remainder == 1)
            return power(3, quotient - 1) * 4ll%mod;
        else
            return power(3, quotient) * 2ll%mod;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,hard,,,,,,,,,,,,,,,,
leetcode47,"The factorial of a positive integer n is the product of all positive integers less than or equal to n.
    For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.
We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.
    For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.
However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.
Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.
Given an integer n, return the clumsy factorial of n.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 4
Output: 7

Example 2:
Input: n = 10
Output: 12

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。
相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。
例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。
另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。
实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 4
Output: 7

样例2：
Input: n = 10
Output: 12

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    int solve(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        } else if (n == 3) {
            return 6;
        } else if (n == 4) {
            return 7;
        }

        if (n % 4 == 0) {
            return n + 1;
        } else if (n % 4 <= 2) {
            return n + 2;
        } else {
            return n - 1;
        }
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode48,"There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:
    Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
    Paste: You can paste the characters which are copied last time.
Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 3
Output: 3

Example 2:
Input: n = 1
Output: 0

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：
    Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
    Paste（粘贴）：粘贴 上一次 复制的字符。
给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 3
Output: 3

样例2：
Input: n = 1
Output: 0

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
public:
    int solve(int n) {
        if (n == 1) return 0; // No steps needed for 1 'A'
        int steps = n; // In the worst case, we will need `n` steps (1 copy and `n-1` pastes)
        for (int d = 2; d <= sqrt(n); ++d) {
            if (n % d == 0) {
                // If `d` is a divisor of `n`, we calculate the steps for `d` and `n / d`
                steps = min(steps, solve(d) + (n / d));
                // Since we only need to consider divisors once, we also check the factor pair `n / d`
                steps = min(steps, solve(n / d) + d);
            }
        }
        return steps;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,,,,,,,,,,,,,,,,
leetcode49,"The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagram:
We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).
1 2 3
4 5 6
7 8 9
* 0 #

'*' and '#' are red,the others are blue
Given an integer n, return how many distinct phone numbers of length n we can dial.
You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.
As the answer may be very large, return the answer modulo 10^9 + 7.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 10

Example 2:
Input: n = 2
Output: 20

Restrictions:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。
1 2 3
4 5 6
7 8 9
* 0 #
*和#是红色其他的是蓝色
你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。
因为答案可能很大，所以输出答案模 10^9 + 7.

solution内主函数
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

样例1：
Input: n = 1
Output: 10

样例2：
Input: n = 2
Output: 20

限制：
1 <= n <= @data
时间限制：@time_limit ms
内存限制：@memory_limit KB",100 1000 1000000,1000,12800 1280 128,"class Solution {
    static constexpr int mod = 1e9 + 7;

public:
    int solve(int n) {
        vector<vector<int>> moves = {
            {4, 6},
            {6, 8},
            {7, 9},
            {4, 8},
            {3, 9, 0},
            {},
            {1, 7, 0},
            {2, 6},
            {1, 3},
            {2, 4}
        };
        vector<vector<int>> d(2, vector<int>(10, 0));
        fill(d[1].begin(), d[1].end(), 1);
        for (int i = 2; i <= n; i++) {
            int x = i & 1;
            for (int j = 0; j < 10; j++) {
                d[x][j] = 0;
                for (int k : moves[j]) {
                    d[x][j] = (d[x][j] + d[x ^ 1][k]) % mod;
                }
            }
        }
        int res = 0;
        for (auto x : d[n % 2]) {
            res = (res + x) % mod;
        }
        return res;
    }
};","#include <algorithm>
#include<bits/stdc++.h>
#include <ratio>
using ll = long long;
using namespace std;
std::mt19937_64 rnd(std::chrono::steady_clock().now().time_since_epoch().count());

int rng(int l, int r) { // [l, r]
    return rnd() % (r - l + 1) + l;
}

int main(int argc, char* argv[]){
    int data = std::atoi(argv[1]);
    int n=rng(data/2,data);
    cout<<n;
    return 0;
}","#include <bits/stdc++.h>
#include <iterator>
#include ""execute.h""
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    catch_error(argc);

    // input
    int n; cin>>n;
    // solve
    Solution solution;
    get_usage(argv[0], argv[1]);
    set_cpu_limit();
    auto result = solution.solve(n);
    get_usage(argv[0], argv[1]);

    // output
    cout<<result;
    return 0;
}",math,middle,"class Solution {
    static constexpr int mod = 1e9 + 7;

public:
    vector<vector<int>> mul(const vector<vector<int>> &lth, const vector<vector<int>> &rth) {
        vector<vector<int>> res(lth.size(), vector<int>(rth[0].size(), 0));
        for (int k = 0; k < lth[0].size(); k++) {
            for (int i = 0; i < lth.size(); i++) {
                for (int j = 0; j < rth[0].size(); j++) {
                    res[i][j] = (res[i][j] + 1ll * lth[i][k] * rth[k][j] % mod) % mod;
                }
            }
        }
        return res;
    }

    int solve(int n) {
        vector<vector<int>> base = {
            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0}
        };
        vector<vector<int>> res = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        };

        vector<vector<int>> base2 = vector<vector<int>>(10, vector<int>(10, 0));
        for (int i = 0; i < 10; i++) {
            base2[i][i] = 1;
        }
        n--;
        while (n > 0) {
            if (n & 1) {
                base2 = mul(base2, base);
            }
            base = mul(base, base);
            n >>= 1;
        }
        res = mul(res, base2);
        int ret = 0;
        for (auto x : res[0]) {
            ret = (ret + x) % mod;
        }

        return ret;
    }
};",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
