在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。

solution内主函数
```cpp
class Solution
{
    public:
    pair< int,vector<string> > solve(int n)
}
```

传入参数:
一个自然数偶数 $n$。

返回参数:
一个整数表示最少需要的操作次数。
一个vector<string>数组，存储着每次操作后桌上硬币的状态（一行包含 $N$ 个整数 $0$ 或 $1$，表示每个硬币的状态，$0$ 表示正面向上，$1$ 表示反面向上。不允许输出多余空格。
对于有多种操作方案的情况，则只需操作的字典序最小输出一种。
操作的字典序是指，对于一次操作中的每个位置，$1$ 表示翻转，$0$ 表示不反转。
但是需要你输出的是每一次操作完的状态，$0$ 表示正面朝上，$1$ 表示反面朝上。

样例1：
Input：n=4
Output: (4,["0111", "1100", "0001", "1111"])

限制：
0<n≤@data
时间限制：@time_limit ms
内存限制：@memory_limit KB